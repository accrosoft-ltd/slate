{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../src/utils/weak-maps.ts","../src/utils/string.ts","../src/interfaces/editor.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts","../src/create-editor.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\r\n\r\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\r\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\r\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\r\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\r\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\r\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\r\n","/**\r\n * Constants for string distance checking.\r\n */\r\n\r\nconst SPACE = /\\s/\r\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\r\nconst CHAMELEON = /['\\u2018\\u2019]/\r\nconst SURROGATE_START = 0xd800\r\nconst SURROGATE_END = 0xdfff\r\nconst ZERO_WIDTH_JOINER = 0x200d\r\n\r\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\r\n\r\nexport const getCharacterDistance = (text: string): number => {\r\n  let offset = 0\r\n  // prev types:\r\n  // SURR: surrogate pair\r\n  // MOD: modifier (technically also surrogate pair)\r\n  // ZWJ: zero width joiner\r\n  // VAR: variation selector\r\n  // BMP: sequenceable character from basic multilingual plane\r\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\r\n  let charCode = text.charCodeAt(0)\r\n\r\n  while (charCode) {\r\n    if (isSurrogate(charCode)) {\r\n      const modifier = isModifier(charCode, text, offset)\r\n\r\n      // Early returns are the heart of this function, where we decide if previous and current\r\n      // codepoints should form a single character (in terms of how many of them should selection\r\n      // jump over).\r\n      if (prev === 'SURR' || prev === 'BMP') {\r\n        break\r\n      }\r\n\r\n      offset += 2\r\n      prev = modifier ? 'MOD' : 'SURR'\r\n      charCode = text.charCodeAt(offset)\r\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\r\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\r\n      continue\r\n    }\r\n\r\n    if (charCode === ZERO_WIDTH_JOINER) {\r\n      offset += 1\r\n      prev = 'ZWJ'\r\n      charCode = text.charCodeAt(offset)\r\n\r\n      continue\r\n    }\r\n\r\n    if (isBMPEmoji(charCode)) {\r\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\r\n        break\r\n      }\r\n      offset += 1\r\n      prev = 'BMP'\r\n      charCode = text.charCodeAt(offset)\r\n\r\n      continue\r\n    }\r\n\r\n    if (isVariationSelector(charCode)) {\r\n      if (prev && prev !== 'ZWJ') {\r\n        break\r\n      }\r\n      offset += 1\r\n      prev = 'VAR'\r\n      charCode = text.charCodeAt(offset)\r\n      continue\r\n    }\r\n\r\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\r\n    // look ahead.\r\n    if (prev === 'MOD') {\r\n      offset += 1\r\n      break\r\n    }\r\n\r\n    // If while loop ever gets here, we're done (e.g latin chars).\r\n    break\r\n  }\r\n\r\n  return offset || 1\r\n}\r\n\r\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\r\n\r\nexport const getWordDistance = (text: string): number => {\r\n  let length = 0\r\n  let i = 0\r\n  let started = false\r\n  let char\r\n\r\n  while ((char = text.charAt(i))) {\r\n    const l = getCharacterDistance(char)\r\n    char = text.slice(i, i + l)\r\n    const rest = text.slice(i + l)\r\n\r\n    if (isWordCharacter(char, rest)) {\r\n      started = true\r\n      length += l\r\n    } else if (!started) {\r\n      length += l\r\n    } else {\r\n      break\r\n    }\r\n\r\n    i += l\r\n  }\r\n\r\n  return length\r\n}\r\n\r\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\r\n\r\nconst isWordCharacter = (char: string, remaining: string): boolean => {\r\n  if (SPACE.test(char)) {\r\n    return false\r\n  }\r\n\r\n  // Chameleons count as word characters as long as they're in a word, so\r\n  // recurse to see if the next one is a word character or not.\r\n  if (CHAMELEON.test(char)) {\r\n    let next = remaining.charAt(0)\r\n    const length = getCharacterDistance(next)\r\n    next = remaining.slice(0, length)\r\n    const rest = remaining.slice(length)\r\n\r\n    if (isWordCharacter(next, rest)) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  if (PUNCTUATION.test(char)) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Determines if `code` is a surrogate\r\n */\r\n\r\nconst isSurrogate = (code: number): boolean =>\r\n  SURROGATE_START <= code && code <= SURROGATE_END\r\n\r\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\r\n\r\nconst isModifier = (code: number, text: string, offset: number): boolean => {\r\n  if (code === 0xd83c) {\r\n    const next = text.charCodeAt(offset + 1)\r\n    return next <= 0xdfff && next >= 0xdffb\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\r\n\r\nconst isVariationSelector = (code: number): boolean => {\r\n  return code <= 0xfe0f && code >= 0xfe00\r\n}\r\n\r\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\r\n\r\nconst isBMPEmoji = (code: number): boolean => {\r\n  // This requires tiny bit of maintanance, better ideas?\r\n  // Fortunately it only happens if new Unicode Standard\r\n  // is released. Fails gracefully if upkeep lags behind,\r\n  // same way Slate previously behaved with all emojis.\r\n  return (\r\n    code === 0x2764 || // heart (❤)\r\n    code === 0x2642 || // male (♂)\r\n    code === 0x2640 || // female (♀)\r\n    code === 0x2620 || // scull (☠)\r\n    code === 0x2695 || // medical (⚕)\r\n    code === 0x2708 || // plane (✈️)\r\n    code === 0x25ef // large circle (◯)\r\n  )\r\n}\r\n","import isPlainObject from 'is-plain-object'\r\nimport { createDraft, finishDraft, isDraft } from 'immer'\r\nimport { reverse as reverseText } from 'esrever'\r\n\r\nimport {\r\n  Ancestor,\r\n  Descendant,\r\n  Element,\r\n  Location,\r\n  Node,\r\n  NodeEntry,\r\n  Operation,\r\n  Path,\r\n  PathRef,\r\n  Point,\r\n  PointRef,\r\n  Range,\r\n  RangeRef,\r\n  Span,\r\n  Text,\r\n} from '..'\r\nimport {\r\n  DIRTY_PATHS,\r\n  NORMALIZING,\r\n  PATH_REFS,\r\n  POINT_REFS,\r\n  RANGE_REFS,\r\n} from '../utils/weak-maps'\r\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\r\n\r\n/**\r\n * The `Editor` interface stores all the state of a Slate editor. It is extended\r\n * by plugins that wish to add their own helpers and implement new behaviors.\r\n */\r\n\r\nexport interface Editor {\r\n  children: Node[]\r\n  selection: Range | null\r\n  operations: Operation[]\r\n  marks: Record<string, any> | null\r\n  [key: string]: any\r\n\r\n  // Schema-specific node behaviors.\r\n  isInline: (element: Element) => boolean\r\n  isVoid: (element: Element) => boolean\r\n  normalizeNode: (entry: NodeEntry) => void\r\n  onChange: () => void\r\n\r\n  // Overrideable core actions.\r\n  addMark: (key: string, value: any) => void\r\n  apply: (operation: Operation) => void\r\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\r\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\r\n  getFragment: () => Descendant[]\r\n  deleteFragment: () => void\r\n  insertBreak: () => void\r\n  insertFragment: (fragment: Node[]) => void\r\n  insertNode: (node: Node) => void\r\n  insertText: (text: string) => void\r\n  removeMark: (key: string) => void\r\n}\r\n\r\nexport const Editor = {\r\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\r\n\r\n  above<T extends Ancestor>(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch<T>\r\n      mode?: 'highest' | 'lowest'\r\n      voids?: boolean\r\n    } = {}\r\n  ): NodeEntry<T> | undefined {\r\n    const {\r\n      voids = false,\r\n      mode = 'lowest',\r\n      at = editor.selection,\r\n      match,\r\n    } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const path = Editor.path(editor, at)\r\n    const reverse = mode === 'lowest'\r\n\r\n    for (const [n, p] of Editor.levels(editor, {\r\n      at: path,\r\n      voids,\r\n      match,\r\n      reverse,\r\n    })) {\r\n      if (!Text.isText(n) && !Path.equals(path, p)) {\r\n        return [n, p]\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\r\n\r\n  addMark(editor: Editor, key: string, value: any): void {\r\n    editor.addMark(key, value)\r\n  },\r\n\r\n  /**\r\n   * Get the point after a location.\r\n   */\r\n\r\n  after(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): Point | undefined {\r\n    const anchor = Editor.point(editor, at, { edge: 'end' })\r\n    const focus = Editor.end(editor, [])\r\n    const range = { anchor, focus }\r\n    const { distance = 1 } = options\r\n    let d = 0\r\n    let target\r\n\r\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\r\n      if (d > distance) {\r\n        break\r\n      }\r\n\r\n      if (d !== 0) {\r\n        target = p\r\n      }\r\n\r\n      d++\r\n    }\r\n\r\n    return target\r\n  },\r\n\r\n  /**\r\n   * Get the point before a location.\r\n   */\r\n\r\n  before(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): Point | undefined {\r\n    const anchor = Editor.start(editor, [])\r\n    const focus = Editor.point(editor, at, { edge: 'start' })\r\n    const range = { anchor, focus }\r\n    const { distance = 1 } = options\r\n    let d = 0\r\n    let target\r\n\r\n    for (const p of Editor.positions(editor, {\r\n      ...options,\r\n      at: range,\r\n      reverse: true,\r\n    })) {\r\n      if (d > distance) {\r\n        break\r\n      }\r\n\r\n      if (d !== 0) {\r\n        target = p\r\n      }\r\n\r\n      d++\r\n    }\r\n\r\n    return target\r\n  },\r\n\r\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\r\n\r\n  deleteBackward(\r\n    editor: Editor,\r\n    options: {\r\n      unit?: 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): void {\r\n    const { unit = 'character' } = options\r\n    editor.deleteBackward(unit)\r\n  },\r\n\r\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\r\n\r\n  deleteForward(\r\n    editor: Editor,\r\n    options: {\r\n      unit?: 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): void {\r\n    const { unit = 'character' } = options\r\n    editor.deleteForward(unit)\r\n  },\r\n\r\n  /**\r\n   * Delete the content in the current selection.\r\n   */\r\n\r\n  deleteFragment(editor: Editor): void {\r\n    editor.deleteFragment()\r\n  },\r\n\r\n  /**\r\n   * Get the start and end points of a location.\r\n   */\r\n\r\n  edges(editor: Editor, at: Location): [Point, Point] {\r\n    return [Editor.start(editor, at), Editor.end(editor, at)]\r\n  },\r\n\r\n  /**\r\n   * Get the end point of a location.\r\n   */\r\n\r\n  end(editor: Editor, at: Location): Point {\r\n    return Editor.point(editor, at, { edge: 'end' })\r\n  },\r\n\r\n  /**\r\n   * Get the first node at a location.\r\n   */\r\n\r\n  first(editor: Editor, at: Location): NodeEntry {\r\n    const path = Editor.path(editor, at, { edge: 'start' })\r\n    return Editor.node(editor, path)\r\n  },\r\n\r\n  /**\r\n   * Get the fragment at a location.\r\n   */\r\n\r\n  fragment(editor: Editor, at: Location): Descendant[] {\r\n    const range = Editor.range(editor, at)\r\n    const fragment = Node.fragment(editor, range)\r\n    return fragment\r\n  },\r\n  /**\r\n   * Check if a node has block children.\r\n   */\r\n\r\n  hasBlocks(editor: Editor, element: Element): boolean {\r\n    return element.children.some(n => Editor.isBlock(editor, n))\r\n  },\r\n\r\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\r\n\r\n  hasInlines(editor: Editor, element: Element): boolean {\r\n    return element.children.some(\r\n      n => Text.isText(n) || Editor.isInline(editor, n)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a node has text children.\r\n   */\r\n\r\n  hasTexts(editor: Editor, element: Element): boolean {\r\n    return element.children.every(n => Text.isText(n))\r\n  },\r\n\r\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\r\n\r\n  insertBreak(editor: Editor): void {\r\n    editor.insertBreak()\r\n  },\r\n\r\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\r\n\r\n  insertFragment(editor: Editor, fragment: Node[]): void {\r\n    editor.insertFragment(fragment)\r\n  },\r\n\r\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\r\n\r\n  insertNode(editor: Editor, node: Node): void {\r\n    editor.insertNode(node)\r\n  },\r\n\r\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\r\n\r\n  insertText(editor: Editor, text: string): void {\r\n    editor.insertText(text)\r\n  },\r\n\r\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\r\n\r\n  isBlock(editor: Editor, value: any): value is Element {\r\n    return Element.isElement(value) && !editor.isInline(value)\r\n  },\r\n\r\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\r\n\r\n  isEditor(value: any): value is Editor {\r\n    return (\r\n      isPlainObject(value) &&\r\n      typeof value.addMark === 'function' &&\r\n      typeof value.apply === 'function' &&\r\n      typeof value.deleteBackward === 'function' &&\r\n      typeof value.deleteForward === 'function' &&\r\n      typeof value.deleteFragment === 'function' &&\r\n      typeof value.insertBreak === 'function' &&\r\n      typeof value.insertFragment === 'function' &&\r\n      typeof value.insertNode === 'function' &&\r\n      typeof value.insertText === 'function' &&\r\n      typeof value.isInline === 'function' &&\r\n      typeof value.isVoid === 'function' &&\r\n      typeof value.normalizeNode === 'function' &&\r\n      typeof value.onChange === 'function' &&\r\n      typeof value.removeMark === 'function' &&\r\n      (value.marks === null || isPlainObject(value.marks)) &&\r\n      (value.selection === null || Range.isRange(value.selection)) &&\r\n      Node.isNodeList(value.children) &&\r\n      Operation.isOperationList(value.operations)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\r\n\r\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\r\n    const end = Editor.end(editor, at)\r\n    return Point.equals(point, end)\r\n  },\r\n\r\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\r\n\r\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\r\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\r\n  },\r\n\r\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\r\n\r\n  isEmpty(editor: Editor, element: Element): boolean {\r\n    const { children } = element\r\n    const [first] = children\r\n    return (\r\n      children.length === 0 ||\r\n      (children.length === 1 &&\r\n        Text.isText(first) &&\r\n        first.text === '' &&\r\n        !editor.isVoid(element))\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\r\n\r\n  isInline(editor: Editor, value: any): value is Element {\r\n    return Element.isElement(value) && editor.isInline(value)\r\n  },\r\n\r\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\r\n\r\n  isNormalizing(editor: Editor): boolean {\r\n    const isNormalizing = NORMALIZING.get(editor)\r\n    return isNormalizing === undefined ? true : isNormalizing\r\n  },\r\n\r\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\r\n\r\n  isStart(editor: Editor, point: Point, at: Location): boolean {\r\n    // PERF: If the offset isn't `0` we know it's not the start.\r\n    if (point.offset !== 0) {\r\n      return false\r\n    }\r\n\r\n    const start = Editor.start(editor, at)\r\n    return Point.equals(point, start)\r\n  },\r\n\r\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\r\n\r\n  isVoid(editor: Editor, value: any): value is Element {\r\n    return Element.isElement(value) && editor.isVoid(value)\r\n  },\r\n\r\n  /**\r\n   * Get the last node at a location.\r\n   */\r\n\r\n  last(editor: Editor, at: Location): NodeEntry {\r\n    const path = Editor.path(editor, at, { edge: 'end' })\r\n    return Editor.node(editor, path)\r\n  },\r\n\r\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\r\n\r\n  leaf(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): NodeEntry<Text> {\r\n    const path = Editor.path(editor, at, options)\r\n    const node = Node.leaf(editor, path)\r\n    return [node, path]\r\n  },\r\n\r\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\r\n\r\n  *levels<T extends Node>(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch<T>\r\n      reverse?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<T>> {\r\n    const { at = editor.selection, reverse = false, voids = false } = options\r\n    let { match } = options\r\n\r\n    if (match == null) {\r\n      match = () => true\r\n    }\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const levels: NodeEntry<T>[] = []\r\n    const path = Editor.path(editor, at)\r\n\r\n    for (const [n, p] of Node.levels(editor, path)) {\r\n      if (!match(n)) {\r\n        continue\r\n      }\r\n\r\n      levels.push([n, p])\r\n\r\n      if (!voids && Editor.isVoid(editor, n)) {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (reverse) {\r\n      levels.reverse()\r\n    }\r\n\r\n    yield* levels\r\n  },\r\n\r\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\r\n\r\n  marks(editor: Editor): Record<string, any> | null {\r\n    const { marks, selection } = editor\r\n\r\n    if (!selection) {\r\n      return null\r\n    }\r\n\r\n    if (marks) {\r\n      return marks\r\n    }\r\n\r\n    if (Range.isExpanded(selection)) {\r\n      const [match] = Editor.nodes(editor, { match: Text.isText })\r\n\r\n      if (match) {\r\n        const [node] = match as NodeEntry<Text>\r\n        const { text, ...rest } = node\r\n        return rest\r\n      } else {\r\n        return {}\r\n      }\r\n    }\r\n\r\n    const { anchor } = selection\r\n    const { path } = anchor\r\n    let [node] = Editor.leaf(editor, path)\r\n\r\n    if (anchor.offset === 0) {\r\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\r\n      const block = Editor.above(editor, {\r\n        match: n => Editor.isBlock(editor, n),\r\n      })\r\n\r\n      if (prev && block) {\r\n        const [prevNode, prevPath] = prev\r\n        const [, blockPath] = block\r\n\r\n        if (Path.isAncestor(blockPath, prevPath)) {\r\n          node = prevNode as Text\r\n        }\r\n      }\r\n    }\r\n\r\n    const { text, ...rest } = node\r\n    return rest\r\n  },\r\n\r\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\r\n\r\n  next<T extends Node>(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch<T>\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      voids?: boolean\r\n    } = {}\r\n  ): NodeEntry<T> | undefined {\r\n    const { mode = 'lowest', voids = false } = options\r\n    let { match, at = editor.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [, from] = Editor.last(editor, at)\r\n    const [, to] = Editor.last(editor, [])\r\n    const span: Span = [from, to]\r\n\r\n    if (Path.isPath(at) && at.length === 0) {\r\n      throw new Error(`Cannot get the next node from the root node!`)\r\n    }\r\n\r\n    if (match == null) {\r\n      if (Path.isPath(at)) {\r\n        const [parent] = Editor.parent(editor, at)\r\n        match = n => parent.children.includes(n)\r\n      } else {\r\n        match = () => true\r\n      }\r\n    }\r\n\r\n    const [, next] = Editor.nodes(editor, { at: span, match, mode, voids })\r\n    return next\r\n  },\r\n\r\n  /**\r\n   * Get the node at a location.\r\n   */\r\n\r\n  node(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): NodeEntry {\r\n    const path = Editor.path(editor, at, options)\r\n    const node = Node.get(editor, path)\r\n    return [node, path]\r\n  },\r\n\r\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\r\n\r\n  *nodes<T extends Node>(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      match?: NodeMatch<T>\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      universal?: boolean\r\n      reverse?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<T>> {\r\n    const {\r\n      at = editor.selection,\r\n      mode = 'all',\r\n      universal = false,\r\n      reverse = false,\r\n      voids = false,\r\n    } = options\r\n    let { match } = options\r\n\r\n    if (!match) {\r\n      match = () => true\r\n    }\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    let from\r\n    let to\r\n\r\n    if (Span.isSpan(at)) {\r\n      from = at[0]\r\n      to = at[1]\r\n    } else {\r\n      const first = Editor.path(editor, at, { edge: 'start' })\r\n      const last = Editor.path(editor, at, { edge: 'end' })\r\n      from = reverse ? last : first\r\n      to = reverse ? first : last\r\n    }\r\n\r\n    const iterable = Node.nodes(editor, {\r\n      reverse,\r\n      from,\r\n      to,\r\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\r\n    })\r\n\r\n    const matches: NodeEntry<T>[] = []\r\n    let hit: NodeEntry<T> | undefined\r\n\r\n    for (const [node, path] of iterable) {\r\n      const isLower = hit && Path.compare(path, hit[1]) === 0\r\n\r\n      // In highest mode any node lower than the last hit is not a match.\r\n      if (mode === 'highest' && isLower) {\r\n        continue\r\n      }\r\n\r\n      if (!match(node)) {\r\n        // If we've arrived at a leaf text node that is not lower than the last\r\n        // hit, then we've found a branch that doesn't include a match, which\r\n        // means the match is not universal.\r\n        if (universal && !isLower && Text.isText(node)) {\r\n          return\r\n        } else {\r\n          continue\r\n        }\r\n      }\r\n\r\n      // If there's a match and it's lower than the last, update the hit.\r\n      if (mode === 'lowest' && isLower) {\r\n        hit = [node, path]\r\n        continue\r\n      }\r\n\r\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\r\n      const emit: NodeEntry<T> | undefined =\r\n        mode === 'lowest' ? hit : [node, path]\r\n\r\n      if (emit) {\r\n        if (universal) {\r\n          matches.push(emit)\r\n        } else {\r\n          yield emit\r\n        }\r\n      }\r\n\r\n      hit = [node, path]\r\n    }\r\n\r\n    // Since lowest is always emitting one behind, catch up at the end.\r\n    if (mode === 'lowest' && hit) {\r\n      if (universal) {\r\n        matches.push(hit)\r\n      } else {\r\n        yield hit\r\n      }\r\n    }\r\n\r\n    // Universal defers to ensure that the match occurs in every branch, so we\r\n    // yield all of the matches after iterating.\r\n    if (universal) {\r\n      yield* matches\r\n    }\r\n  },\r\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\r\n\r\n  normalize(\r\n    editor: Editor,\r\n    options: {\r\n      force?: boolean\r\n    } = {}\r\n  ) {\r\n    const { force = false } = options\r\n    const getDirtyPaths = (editor: Editor) => {\r\n      return DIRTY_PATHS.get(editor) || []\r\n    }\r\n\r\n    if (!Editor.isNormalizing(editor)) {\r\n      return\r\n    }\r\n\r\n    if (force) {\r\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\r\n      DIRTY_PATHS.set(editor, allPaths)\r\n    }\r\n\r\n    if (getDirtyPaths(editor).length === 0) {\r\n      return\r\n    }\r\n\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\r\n      let m = 0\r\n\r\n      while (getDirtyPaths(editor).length !== 0) {\r\n        if (m > max) {\r\n          throw new Error(`\r\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\r\n          `)\r\n        }\r\n\r\n        const path = getDirtyPaths(editor).pop()!\r\n        const entry = Editor.node(editor, path)\r\n        editor.normalizeNode(entry)\r\n        m++\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Get the parent node of a location.\r\n   */\r\n\r\n  parent(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): NodeEntry<Ancestor> {\r\n    const path = Editor.path(editor, at, options)\r\n    const parentPath = Path.parent(path)\r\n    const entry = Editor.node(editor, parentPath)\r\n    return entry as NodeEntry<Ancestor>\r\n  },\r\n\r\n  /**\r\n   * Get the path of a location.\r\n   */\r\n\r\n  path(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): Path {\r\n    const { depth, edge } = options\r\n\r\n    if (Path.isPath(at)) {\r\n      if (edge === 'start') {\r\n        const [, firstPath] = Node.first(editor, at)\r\n        at = firstPath\r\n      } else if (edge === 'end') {\r\n        const [, lastPath] = Node.last(editor, at)\r\n        at = lastPath\r\n      }\r\n    }\r\n\r\n    if (Range.isRange(at)) {\r\n      if (edge === 'start') {\r\n        at = Range.start(at)\r\n      } else if (edge === 'end') {\r\n        at = Range.end(at)\r\n      } else {\r\n        at = Path.common(at.anchor.path, at.focus.path)\r\n      }\r\n    }\r\n\r\n    if (Point.isPoint(at)) {\r\n      at = at.path\r\n    }\r\n\r\n    if (depth != null) {\r\n      at = at.slice(0, depth)\r\n    }\r\n\r\n    return at\r\n  },\r\n\r\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\r\n\r\n  pathRef(\r\n    editor: Editor,\r\n    path: Path,\r\n    options: {\r\n      affinity?: 'backward' | 'forward' | null\r\n    } = {}\r\n  ): PathRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: PathRef = {\r\n      current: path,\r\n      affinity,\r\n      unref() {\r\n        const { current } = ref\r\n        const pathRefs = Editor.pathRefs(editor)\r\n        pathRefs.delete(ref)\r\n        ref.current = null\r\n        return current\r\n      },\r\n    }\r\n\r\n    const refs = Editor.pathRefs(editor)\r\n    refs.add(ref)\r\n    return ref\r\n  },\r\n\r\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\r\n\r\n  pathRefs(editor: Editor): Set<PathRef> {\r\n    let refs = PATH_REFS.get(editor)\r\n\r\n    if (!refs) {\r\n      refs = new Set()\r\n      PATH_REFS.set(editor, refs)\r\n    }\r\n\r\n    return refs\r\n  },\r\n\r\n  /**\r\n   * Get the start or end point of a location.\r\n   */\r\n\r\n  point(\r\n    editor: Editor,\r\n    at: Location,\r\n    options: {\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): Point {\r\n    const { edge = 'start' } = options\r\n\r\n    if (Path.isPath(at)) {\r\n      let path\r\n\r\n      if (edge === 'end') {\r\n        const [, lastPath] = Node.last(editor, at)\r\n        path = lastPath\r\n      } else {\r\n        const [, firstPath] = Node.first(editor, at)\r\n        path = firstPath\r\n      }\r\n\r\n      const node = Node.get(editor, path)\r\n\r\n      if (!Text.isText(node)) {\r\n        throw new Error(\r\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\r\n        )\r\n      }\r\n\r\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\r\n    }\r\n\r\n    if (Range.isRange(at)) {\r\n      const [start, end] = Range.edges(at)\r\n      return edge === 'start' ? start : end\r\n    }\r\n\r\n    return at\r\n  },\r\n\r\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\r\n\r\n  pointRef(\r\n    editor: Editor,\r\n    point: Point,\r\n    options: {\r\n      affinity?: 'backward' | 'forward' | null\r\n    } = {}\r\n  ): PointRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: PointRef = {\r\n      current: point,\r\n      affinity,\r\n      unref() {\r\n        const { current } = ref\r\n        const pointRefs = Editor.pointRefs(editor)\r\n        pointRefs.delete(ref)\r\n        ref.current = null\r\n        return current\r\n      },\r\n    }\r\n\r\n    const refs = Editor.pointRefs(editor)\r\n    refs.add(ref)\r\n    return ref\r\n  },\r\n\r\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\r\n\r\n  pointRefs(editor: Editor): Set<PointRef> {\r\n    let refs = POINT_REFS.get(editor)\r\n\r\n    if (!refs) {\r\n      refs = new Set()\r\n      POINT_REFS.set(editor, refs)\r\n    }\r\n\r\n    return refs\r\n  },\r\n\r\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\r\n\r\n  *positions(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<Point> {\r\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const range = Editor.range(editor, at)\r\n    const [start, end] = Range.edges(range)\r\n    const first = reverse ? end : start\r\n    let string = ''\r\n    let available = 0\r\n    let offset = 0\r\n    let distance: number | null = null\r\n    let isNewBlock = false\r\n\r\n    const advance = () => {\r\n      if (distance == null) {\r\n        if (unit === 'character') {\r\n          distance = getCharacterDistance(string)\r\n        } else if (unit === 'word') {\r\n          distance = getWordDistance(string)\r\n        } else if (unit === 'line' || unit === 'block') {\r\n          distance = string.length\r\n        } else {\r\n          distance = 1\r\n        }\r\n\r\n        string = string.slice(distance)\r\n      }\r\n\r\n      // Add or substract the offset.\r\n      offset = reverse ? offset - distance : offset + distance\r\n      // Subtract the distance traveled from the available text.\r\n      available = available - distance!\r\n      // If the available had room to spare, reset the distance so that it will\r\n      // advance again next time. Otherwise, set it to the overflow amount.\r\n      distance = available >= 0 ? null : 0 - available\r\n    }\r\n\r\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\r\n      if (Element.isElement(node)) {\r\n        // Void nodes are a special case, since we don't want to iterate over\r\n        // their content. We instead always just yield their first point.\r\n        if (editor.isVoid(node)) {\r\n          yield Editor.start(editor, path)\r\n          continue\r\n        }\r\n\r\n        if (editor.isInline(node)) {\r\n          continue\r\n        }\r\n\r\n        if (Editor.hasInlines(editor, node)) {\r\n          const e = Path.isAncestor(path, end.path)\r\n            ? end\r\n            : Editor.end(editor, path)\r\n          const s = Path.isAncestor(path, start.path)\r\n            ? start\r\n            : Editor.start(editor, path)\r\n\r\n          const text = Editor.string(editor, { anchor: s, focus: e })\r\n          string = reverse ? reverseText(text) : text\r\n          isNewBlock = true\r\n        }\r\n      }\r\n\r\n      if (Text.isText(node)) {\r\n        const isFirst = Path.equals(path, first.path)\r\n        available = node.text.length\r\n        offset = reverse ? available : 0\r\n\r\n        if (isFirst) {\r\n          available = reverse ? first.offset : available - first.offset\r\n          offset = first.offset\r\n        }\r\n\r\n        if (isFirst || isNewBlock || unit === 'offset') {\r\n          yield { path, offset }\r\n        }\r\n\r\n        while (true) {\r\n          // If there's no more string, continue to the next block.\r\n          if (string === '') {\r\n            break\r\n          } else {\r\n            advance()\r\n          }\r\n\r\n          // If the available space hasn't overflow, we have another point to\r\n          // yield in the current text node.\r\n          if (available >= 0) {\r\n            yield { path, offset }\r\n          } else {\r\n            break\r\n          }\r\n        }\r\n\r\n        isNewBlock = false\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\r\n\r\n  previous<T extends Node>(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch<T>\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      voids?: boolean\r\n    } = {}\r\n  ): NodeEntry<T> | undefined {\r\n    const { mode = 'lowest', voids = false } = options\r\n    let { match, at = editor.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [, from] = Editor.first(editor, at)\r\n    const [, to] = Editor.first(editor, [])\r\n    const span: Span = [from, to]\r\n\r\n    if (Path.isPath(at) && at.length === 0) {\r\n      throw new Error(`Cannot get the previous node from the root node!`)\r\n    }\r\n\r\n    if (match == null) {\r\n      if (Path.isPath(at)) {\r\n        const [parent] = Editor.parent(editor, at)\r\n        match = n => parent.children.includes(n)\r\n      } else {\r\n        match = () => true\r\n      }\r\n    }\r\n\r\n    const [, previous] = Editor.nodes(editor, {\r\n      reverse: true,\r\n      at: span,\r\n      match,\r\n      mode,\r\n      voids,\r\n    })\r\n\r\n    return previous\r\n  },\r\n\r\n  /**\r\n   * Get a range of a location.\r\n   */\r\n\r\n  range(editor: Editor, at: Location, to?: Location): Range {\r\n    if (Range.isRange(at) && !to) {\r\n      return at\r\n    }\r\n\r\n    const start = Editor.start(editor, at)\r\n    const end = Editor.end(editor, to || at)\r\n    return { anchor: start, focus: end }\r\n  },\r\n\r\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\r\n\r\n  rangeRef(\r\n    editor: Editor,\r\n    range: Range,\r\n    options: {\r\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\r\n    } = {}\r\n  ): RangeRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: RangeRef = {\r\n      current: range,\r\n      affinity,\r\n      unref() {\r\n        const { current } = ref\r\n        const rangeRefs = Editor.rangeRefs(editor)\r\n        rangeRefs.delete(ref)\r\n        ref.current = null\r\n        return current\r\n      },\r\n    }\r\n\r\n    const refs = Editor.rangeRefs(editor)\r\n    refs.add(ref)\r\n    return ref\r\n  },\r\n\r\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\r\n\r\n  rangeRefs(editor: Editor): Set<RangeRef> {\r\n    let refs = RANGE_REFS.get(editor)\r\n\r\n    if (!refs) {\r\n      refs = new Set()\r\n      RANGE_REFS.set(editor, refs)\r\n    }\r\n\r\n    return refs\r\n  },\r\n\r\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\r\n\r\n  removeMark(editor: Editor, key: string): void {\r\n    editor.removeMark(key)\r\n  },\r\n\r\n  /**\r\n   * Get the start point of a location.\r\n   */\r\n\r\n  start(editor: Editor, at: Location): Point {\r\n    return Editor.point(editor, at, { edge: 'start' })\r\n  },\r\n\r\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\r\n\r\n  string(editor: Editor, at: Location): string {\r\n    const range = Editor.range(editor, at)\r\n    const [start, end] = Range.edges(range)\r\n    let text = ''\r\n\r\n    for (const [node, path] of Editor.nodes(editor, {\r\n      at: range,\r\n      match: Text.isText,\r\n    })) {\r\n      let t = node.text\r\n\r\n      if (Path.equals(path, end.path)) {\r\n        t = t.slice(0, end.offset)\r\n      }\r\n\r\n      if (Path.equals(path, start.path)) {\r\n        t = t.slice(start.offset)\r\n      }\r\n\r\n      text += t\r\n    }\r\n\r\n    return text\r\n  },\r\n\r\n  /**\r\n   * Transform the editor by an operation.\r\n   */\r\n\r\n  transform(editor: Editor, op: Operation) {\r\n    editor.children = createDraft(editor.children)\r\n    let selection = editor.selection && createDraft(editor.selection)\r\n\r\n    switch (op.type) {\r\n      case 'insert_node': {\r\n        const { path, node } = op\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n        parent.children.splice(index, 0, node)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'insert_text': {\r\n        const { path, offset, text } = op\r\n        const node = Node.leaf(editor, path)\r\n        const before = node.text.slice(0, offset)\r\n        const after = node.text.slice(offset)\r\n        node.text = before + text + after\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'merge_node': {\r\n        const { path } = op\r\n        const node = Node.get(editor, path)\r\n        const prevPath = Path.previous(path)\r\n        const prev = Node.get(editor, prevPath)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n\r\n        if (Text.isText(node) && Text.isText(prev)) {\r\n          prev.text += node.text\r\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\r\n          prev.children.push(...node.children)\r\n        } else {\r\n          throw new Error(\r\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\r\n          )\r\n        }\r\n\r\n        parent.children.splice(index, 1)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'move_node': {\r\n        const { path, newPath } = op\r\n\r\n        if (Path.isAncestor(path, newPath)) {\r\n          throw new Error(\r\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\r\n          )\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n\r\n        // This is tricky, but since the `path` and `newPath` both refer to\r\n        // the same snapshot in time, there's a mismatch. After either\r\n        // removing the original position, the second step's path can be out\r\n        // of date. So instead of using the `op.newPath` directly, we\r\n        // transform `op.path` to ascertain what the `newPath` would be after\r\n        // the operation was applied.\r\n        parent.children.splice(index, 1)\r\n        const truePath = Path.transform(path, op)!\r\n        const newParent = Node.get(editor, Path.parent(truePath))\r\n        const newIndex = truePath[truePath.length - 1]\r\n\r\n        newParent.children.splice(newIndex, 0, node)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'remove_node': {\r\n        const { path } = op\r\n        const index = path[path.length - 1]\r\n        const parent = Node.parent(editor, path)\r\n        parent.children.splice(index, 1)\r\n\r\n        // Transform all of the points in the value, but if the point was in the\r\n        // node that was removed we need to update the range or remove it.\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            const result = Point.transform(point, op)\r\n\r\n            if (selection != null && result != null) {\r\n              selection[key] = result\r\n            } else {\r\n              let prev: NodeEntry<Text> | undefined\r\n              let next: NodeEntry<Text> | undefined\r\n\r\n              for (const [n, p] of Node.texts(editor)) {\r\n                if (Path.compare(p, path) === -1) {\r\n                  prev = [n, p]\r\n                } else {\r\n                  next = [n, p]\r\n                  break\r\n                }\r\n              }\r\n\r\n              if (prev) {\r\n                point.path = prev[1]\r\n                point.offset = prev[0].text.length\r\n              } else if (next) {\r\n                point.path = next[1]\r\n                point.offset = 0\r\n              } else {\r\n                selection = null\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'remove_text': {\r\n        const { path, offset, text } = op\r\n        const node = Node.leaf(editor, path)\r\n        const before = node.text.slice(0, offset)\r\n        const after = node.text.slice(offset + text.length)\r\n        node.text = before + after\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'set_node': {\r\n        const { path, newProperties } = op\r\n\r\n        if (path.length === 0) {\r\n          throw new Error(`Cannot set properties on the root node!`)\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n\r\n        for (const key in newProperties) {\r\n          if (key === 'children' || key === 'text') {\r\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\r\n          }\r\n\r\n          const value = newProperties[key]\r\n\r\n          if (value == null) {\r\n            delete node[key]\r\n          } else {\r\n            node[key] = value\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'set_selection': {\r\n        const { newProperties } = op\r\n\r\n        if (newProperties == null) {\r\n          selection = newProperties\r\n        } else if (selection == null) {\r\n          if (!Range.isRange(newProperties)) {\r\n            throw new Error(\r\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\r\n                newProperties\r\n              )} when there is no current selection.`\r\n            )\r\n          }\r\n\r\n          selection = newProperties\r\n        } else {\r\n          Object.assign(selection, newProperties)\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'split_node': {\r\n        const { path, position, properties } = op\r\n\r\n        if (path.length === 0) {\r\n          throw new Error(\r\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\r\n          )\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n        let newNode: Descendant\r\n\r\n        if (Text.isText(node)) {\r\n          const before = node.text.slice(0, position)\r\n          const after = node.text.slice(position)\r\n          node.text = before\r\n          newNode = {\r\n            ...node,\r\n            ...(properties as Partial<Text>),\r\n            text: after,\r\n          }\r\n        } else {\r\n          const before = node.children.slice(0, position)\r\n          const after = node.children.slice(position)\r\n          node.children = before\r\n\r\n          newNode = {\r\n            ...node,\r\n            ...(properties as Partial<Element>),\r\n            children: after,\r\n          }\r\n        }\r\n\r\n        parent.children.splice(index + 1, 0, newNode)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n    }\r\n\r\n    editor.children = finishDraft(editor.children) as Node[]\r\n\r\n    if (selection) {\r\n      editor.selection = isDraft(selection)\r\n        ? (finishDraft(selection) as Range)\r\n        : selection\r\n    } else {\r\n      editor.selection = null\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\r\n\r\n  unhangRange(\r\n    editor: Editor,\r\n    range: Range,\r\n    options: {\r\n      voids?: boolean\r\n    } = {}\r\n  ): Range {\r\n    const { voids = false } = options\r\n    let [start, end] = Range.edges(range)\r\n\r\n    // PERF: exit early if we can guarantee that the range isn't hanging.\r\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\r\n      return range\r\n    }\r\n\r\n    const endBlock = Editor.above(editor, {\r\n      at: end,\r\n      match: n => Editor.isBlock(editor, n),\r\n    })\r\n    const blockPath = endBlock ? endBlock[1] : []\r\n    const first = Editor.start(editor, [])\r\n    const before = { anchor: first, focus: end }\r\n    let skip = true\r\n\r\n    for (const [node, path] of Editor.nodes(editor, {\r\n      at: before,\r\n      match: Text.isText,\r\n      reverse: true,\r\n      voids,\r\n    })) {\r\n      if (skip) {\r\n        skip = false\r\n        continue\r\n      }\r\n\r\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\r\n        end = { path, offset: node.text.length }\r\n        break\r\n      }\r\n    }\r\n\r\n    return { anchor: start, focus: end }\r\n  },\r\n\r\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\r\n\r\n  void(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      mode?: 'highest' | 'lowest'\r\n      voids?: boolean\r\n    } = {}\r\n  ): NodeEntry<Element> | undefined {\r\n    return Editor.above(editor, {\r\n      ...options,\r\n      match: n => Editor.isVoid(editor, n),\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\r\n\r\n  withoutNormalizing(editor: Editor, fn: () => void): void {\r\n    const value = Editor.isNormalizing(editor)\r\n    NORMALIZING.set(editor, false)\r\n    fn()\r\n    NORMALIZING.set(editor, value)\r\n    Editor.normalize(editor)\r\n  },\r\n}\r\n\r\n/**\r\n * A helper type for narrowing matched nodes with a predicate.\r\n */\r\n\r\ntype NodeMatch<T extends Node> =\r\n  | ((node: Node) => node is T)\r\n  | ((node: Node) => boolean)\r\n","import isPlainObject from 'is-plain-object'\r\nimport { Editor, Node, Path } from '..'\r\n\r\n/**\r\n * `Element` objects are a type of node in a Slate document that contain other\r\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\r\n * depending on the Slate editor's configuration.\r\n */\r\n\r\nexport interface Element {\r\n  children: Node[]\r\n  [key: string]: any\r\n}\r\n\r\nexport const Element = {\r\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\r\n\r\n  isElement(value: any): value is Element {\r\n    return (\r\n      isPlainObject(value) &&\r\n      Node.isNodeList(value.children) &&\r\n      !Editor.isEditor(value)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\r\n\r\n  isElementList(value: any): value is Element[] {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || Element.isElement(value[0]))\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\r\n\r\n  matches(element: Element, props: Partial<Element>): boolean {\r\n    for (const key in props) {\r\n      if (key === 'children') {\r\n        continue\r\n      }\r\n\r\n      if (element[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  },\r\n}\r\n\r\n/**\r\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\r\n * found inside a root node.\r\n */\r\n\r\nexport type ElementEntry = [Element, Path]\r\n","import { Path, Point, Range } from '..'\r\n\r\n/**\r\n * The `Location` interface is a union of the ways to refer to a specific\r\n * location in a Slate document: paths, points or ranges.\r\n *\r\n * Methods will often accept a `Location` instead of requiring only a `Path`,\r\n * `Point` or `Range`. This eliminates the need for developers to manage\r\n * converting between the different interfaces in their own code base.\r\n */\r\n\r\nexport type Location = Path | Point | Range\r\n\r\nexport const Location = {\r\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\r\n\r\n  isLocation(value: any): value is Location {\r\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\r\n  },\r\n}\r\n\r\n/**\r\n * The `Span` interface is a low-level way to refer to locations in nodes\r\n * without using `Point` which requires leaf text nodes to be present.\r\n */\r\n\r\nexport type Span = [Path, Path]\r\n\r\nexport const Span = {\r\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\r\n\r\n  isSpan(value: any): value is Span {\r\n    return (\r\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\r\n    )\r\n  },\r\n}\r\n","import { produce } from 'immer'\r\nimport { Editor, Element, ElementEntry, Path, Range, Text } from '..'\r\n\r\n/**\r\n * The `Node` union type represents all of the different types of nodes that\r\n * occur in a Slate document tree.\r\n */\r\n\r\nexport type Node = Editor | Element | Text\r\n\r\nexport const Node = {\r\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\r\n\r\n  ancestor(root: Node, path: Path): Ancestor {\r\n    const node = Node.get(root, path)\r\n\r\n    if (Text.isText(node)) {\r\n      throw new Error(\r\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\r\n\r\n  *ancestors(\r\n    root: Node,\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<Ancestor>> {\r\n    for (const p of Path.ancestors(path, options)) {\r\n      const n = Node.ancestor(root, p)\r\n      const entry: NodeEntry<Ancestor> = [n, p]\r\n      yield entry\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\r\n\r\n  child(root: Node, index: number): Descendant {\r\n    if (Text.isText(root)) {\r\n      throw new Error(\r\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\r\n      )\r\n    }\r\n\r\n    const c = root.children[index] as Descendant\r\n\r\n    if (c == null) {\r\n      throw new Error(\r\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\r\n          root\r\n        )}`\r\n      )\r\n    }\r\n\r\n    return c\r\n  },\r\n\r\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\r\n\r\n  *children(\r\n    root: Node,\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<Descendant>> {\r\n    const { reverse = false } = options\r\n    const ancestor = Node.ancestor(root, path)\r\n    const { children } = ancestor\r\n    let index = reverse ? children.length - 1 : 0\r\n\r\n    while (reverse ? index >= 0 : index < children.length) {\r\n      const child = Node.child(ancestor, index)\r\n      const childPath = path.concat(index)\r\n      yield [child, childPath]\r\n      index = reverse ? index - 1 : index + 1\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\r\n\r\n  common(root: Node, path: Path, another: Path): NodeEntry {\r\n    const p = Path.common(path, another)\r\n    const n = Node.get(root, p)\r\n    return [n, p]\r\n  },\r\n\r\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\r\n\r\n  descendant(root: Node, path: Path): Descendant {\r\n    const node = Node.get(root, path)\r\n\r\n    if (Editor.isEditor(node)) {\r\n      throw new Error(\r\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of all the descendant node entries inside a root node.\r\n   */\r\n\r\n  *descendants(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<Descendant>> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (path.length !== 0) {\r\n        // NOTE: we have to coerce here because checking the path's length does\r\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\r\n        yield [node, path] as NodeEntry<Descendant>\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\r\n\r\n  *elements(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<ElementEntry> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (Element.isElement(node)) {\r\n        yield [node, path]\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\r\n\r\n  first(root: Node, path: Path): NodeEntry {\r\n    const p = path.slice()\r\n    let n = Node.get(root, p)\r\n\r\n    while (n) {\r\n      if (Text.isText(n) || n.children.length === 0) {\r\n        break\r\n      } else {\r\n        n = n.children[0]\r\n        p.push(0)\r\n      }\r\n    }\r\n\r\n    return [n, p]\r\n  },\r\n\r\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\r\n\r\n  fragment(root: Node, range: Range): Descendant[] {\r\n    if (Text.isText(root)) {\r\n      throw new Error(\r\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\r\n          root\r\n        )}`\r\n      )\r\n    }\r\n\r\n    const newRoot = produce(root, r => {\r\n      const [start, end] = Range.edges(range)\r\n      const iterable = Node.nodes(r, {\r\n        reverse: true,\r\n        pass: ([, path]) => !Range.includes(range, path),\r\n      })\r\n\r\n      for (const [, path] of iterable) {\r\n        if (!Range.includes(range, path)) {\r\n          const parent = Node.parent(r, path)\r\n          const index = path[path.length - 1]\r\n          parent.children.splice(index, 1)\r\n        }\r\n\r\n        if (Path.equals(path, end.path)) {\r\n          const leaf = Node.leaf(r, path)\r\n          leaf.text = leaf.text.slice(0, end.offset)\r\n        }\r\n\r\n        if (Path.equals(path, start.path)) {\r\n          const leaf = Node.leaf(r, path)\r\n          leaf.text = leaf.text.slice(start.offset)\r\n        }\r\n      }\r\n\r\n      delete r.selection\r\n    })\r\n\r\n    return newRoot.children\r\n  },\r\n\r\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\r\n\r\n  get(root: Node, path: Path): Node {\r\n    let node = root\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n      const p = path[i]\r\n\r\n      if (Text.isText(node) || !node.children[p]) {\r\n        throw new Error(\r\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\r\n            root\r\n          )}`\r\n        )\r\n      }\r\n\r\n      node = node.children[p]\r\n    }\r\n\r\n    return node\r\n  },\r\n\r\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\r\n\r\n  has(root: Node, path: Path): boolean {\r\n    let node = root\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n      const p = path[i]\r\n\r\n      if (Text.isText(node) || !node.children[p]) {\r\n        return false\r\n      }\r\n\r\n      node = node.children[p]\r\n    }\r\n\r\n    return true\r\n  },\r\n\r\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\r\n\r\n  isNode(value: any): value is Node {\r\n    return (\r\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\r\n\r\n  isNodeList(value: any): value is Node[] {\r\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\r\n  },\r\n\r\n  /**\r\n   * Get the lash node entry in a root node from a path.\r\n   */\r\n\r\n  last(root: Node, path: Path): NodeEntry {\r\n    const p = path.slice()\r\n    let n = Node.get(root, p)\r\n\r\n    while (n) {\r\n      if (Text.isText(n) || n.children.length === 0) {\r\n        break\r\n      } else {\r\n        const i = n.children.length - 1\r\n        n = n.children[i]\r\n        p.push(i)\r\n      }\r\n    }\r\n\r\n    return [n, p]\r\n  },\r\n\r\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\r\n\r\n  leaf(root: Node, path: Path): Text {\r\n    const node = Node.get(root, path)\r\n\r\n    if (!Text.isText(node)) {\r\n      throw new Error(\r\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\r\n\r\n  *levels(\r\n    root: Node,\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    for (const p of Path.levels(path, options)) {\r\n      const n = Node.get(root, p)\r\n      yield [n, p]\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\r\n\r\n  matches(node: Node, props: Partial<Node>): boolean {\r\n    return (\r\n      (Element.isElement(node) && Element.matches(node, props)) ||\r\n      (Text.isText(node) && Text.matches(node, props))\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\r\n\r\n  *nodes(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (entry: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    const { pass, reverse = false } = options\r\n    const { from = [], to } = options\r\n    const visited = new Set()\r\n    let p: Path = []\r\n    let n = root\r\n\r\n    while (true) {\r\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\r\n        break\r\n      }\r\n\r\n      if (!visited.has(n)) {\r\n        yield [n, p]\r\n      }\r\n\r\n      // If we're allowed to go downward and we haven't decsended yet, do.\r\n      if (\r\n        !visited.has(n) &&\r\n        !Text.isText(n) &&\r\n        n.children.length !== 0 &&\r\n        (pass == null || pass([n, p]) === false)\r\n      ) {\r\n        visited.add(n)\r\n        let nextIndex = reverse ? n.children.length - 1 : 0\r\n\r\n        if (Path.isAncestor(p, from)) {\r\n          nextIndex = from[p.length]\r\n        }\r\n\r\n        p = p.concat(nextIndex)\r\n        n = Node.get(root, p)\r\n        continue\r\n      }\r\n\r\n      // If we're at the root and we can't go down, we're done.\r\n      if (p.length === 0) {\r\n        break\r\n      }\r\n\r\n      // If we're going forward...\r\n      if (!reverse) {\r\n        const newPath = Path.next(p)\r\n\r\n        if (Node.has(root, newPath)) {\r\n          p = newPath\r\n          n = Node.get(root, p)\r\n          continue\r\n        }\r\n      }\r\n\r\n      // If we're going backward...\r\n      if (reverse && p[p.length - 1] !== 0) {\r\n        const newPath = Path.previous(p)\r\n        p = newPath\r\n        n = Node.get(root, p)\r\n        continue\r\n      }\r\n\r\n      // Otherwise we're going upward...\r\n      p = Path.parent(p)\r\n      n = Node.get(root, p)\r\n      visited.add(n)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\r\n\r\n  parent(root: Node, path: Path): Ancestor {\r\n    const parentPath = Path.parent(path)\r\n    const p = Node.get(root, parentPath)\r\n\r\n    if (Text.isText(p)) {\r\n      throw new Error(\r\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\r\n      )\r\n    }\r\n\r\n    return p\r\n  },\r\n\r\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\r\n\r\n  string(node: Node): string {\r\n    if (Text.isText(node)) {\r\n      return node.text\r\n    } else {\r\n      return node.children.map(Node.string).join('')\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Return an iterable of all leaf text nodes in a root node.\r\n   */\r\n\r\n  *texts(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry<Text>> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (Text.isText(node)) {\r\n        yield [node, path]\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\n/**\r\n * The `Descendant` union type represents nodes that are descendants in the\r\n * tree. It is returned as a convenience in certain cases to narrow a value\r\n * further than the more generic `Node` union.\r\n */\r\n\r\nexport type Descendant = Element | Text\r\n\r\n/**\r\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\r\n * It is returned as a convenience in certain cases to narrow a value further\r\n * than the more generic `Node` union.\r\n */\r\n\r\nexport type Ancestor = Editor | Element\r\n\r\n/**\r\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\r\n * document tree. They consist of the node and its `Path` relative to the root\r\n * node in the document.\r\n */\r\n\r\nexport type NodeEntry<T extends Node = Node> = [T, Path]\r\n","import { Node, Path, Range } from '..'\r\nimport isPlainObject from 'is-plain-object'\r\n\r\nexport type InsertNodeOperation = {\r\n  type: 'insert_node'\r\n  path: Path\r\n  node: Node\r\n  [key: string]: any\r\n}\r\n\r\nexport type InsertTextOperation = {\r\n  type: 'insert_text'\r\n  path: Path\r\n  offset: number\r\n  text: string\r\n  [key: string]: any\r\n}\r\n\r\nexport type MergeNodeOperation = {\r\n  type: 'merge_node'\r\n  path: Path\r\n  position: number\r\n  target: number | null\r\n  properties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\nexport type MoveNodeOperation = {\r\n  type: 'move_node'\r\n  path: Path\r\n  newPath: Path\r\n  [key: string]: any\r\n}\r\n\r\nexport type RemoveNodeOperation = {\r\n  type: 'remove_node'\r\n  path: Path\r\n  node: Node\r\n  [key: string]: any\r\n}\r\n\r\nexport type RemoveTextOperation = {\r\n  type: 'remove_text'\r\n  path: Path\r\n  offset: number\r\n  text: string\r\n  [key: string]: any\r\n}\r\n\r\nexport type SetNodeOperation = {\r\n  type: 'set_node'\r\n  path: Path\r\n  properties: Partial<Node>\r\n  newProperties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\nexport type SetSelectionOperation =\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: null\r\n      newProperties: Range\r\n    }\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: Partial<Range>\r\n      newProperties: Partial<Range>\r\n    }\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: Range\r\n      newProperties: null\r\n    }\r\n\r\nexport type SplitNodeOperation = {\r\n  type: 'split_node'\r\n  path: Path\r\n  position: number\r\n  target: number | null\r\n  properties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\nexport type NodeOperation =\r\n  | InsertNodeOperation\r\n  | MergeNodeOperation\r\n  | MoveNodeOperation\r\n  | RemoveNodeOperation\r\n  | SetNodeOperation\r\n  | SplitNodeOperation\r\n\r\nexport type SelectionOperation = SetSelectionOperation\r\n\r\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\r\n\r\n/**\r\n * `Operation` objects define the low-level instructions that Slate editors use\r\n * to apply changes to their internal state. Representing all changes as\r\n * operations is what allows Slate editors to easily implement history,\r\n * collaboration, and other features.\r\n */\r\n\r\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\r\n\r\nexport const Operation = {\r\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\r\n\r\n  isNodeOperation(value: any): value is NodeOperation {\r\n    return Operation.isOperation(value) && value.type.endsWith('_node')\r\n  },\r\n\r\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\r\n\r\n  isOperation(value: any): value is Operation {\r\n    if (!isPlainObject(value)) {\r\n      return false\r\n    }\r\n\r\n    switch (value.type) {\r\n      case 'insert_node':\r\n        return Path.isPath(value.path) && Node.isNode(value.node)\r\n      case 'insert_text':\r\n        return (\r\n          typeof value.offset === 'number' &&\r\n          typeof value.text === 'string' &&\r\n          Path.isPath(value.path)\r\n        )\r\n      case 'merge_node':\r\n        return (\r\n          typeof value.position === 'number' &&\r\n          (typeof value.target === 'number' || value.target === null) &&\r\n          Path.isPath(value.path) &&\r\n          isPlainObject(value.properties)\r\n        )\r\n      case 'move_node':\r\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\r\n      case 'remove_node':\r\n        return Path.isPath(value.path) && Node.isNode(value.node)\r\n      case 'remove_text':\r\n        return (\r\n          typeof value.offset === 'number' &&\r\n          typeof value.text === 'string' &&\r\n          Path.isPath(value.path)\r\n        )\r\n      case 'set_node':\r\n        return (\r\n          Path.isPath(value.path) &&\r\n          isPlainObject(value.properties) &&\r\n          isPlainObject(value.newProperties)\r\n        )\r\n      case 'set_selection':\r\n        return (\r\n          (value.properties === null && Range.isRange(value.newProperties)) ||\r\n          (value.newProperties === null && Range.isRange(value.properties)) ||\r\n          (isPlainObject(value.properties) &&\r\n            isPlainObject(value.newProperties))\r\n        )\r\n      case 'split_node':\r\n        return (\r\n          Path.isPath(value.path) &&\r\n          typeof value.position === 'number' &&\r\n          (typeof value.target === 'number' || value.target === null) &&\r\n          isPlainObject(value.properties)\r\n        )\r\n      default:\r\n        return false\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\r\n\r\n  isOperationList(value: any): value is Operation[] {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || Operation.isOperation(value[0]))\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\r\n\r\n  isSelectionOperation(value: any): value is SelectionOperation {\r\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\r\n  },\r\n\r\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\r\n\r\n  isTextOperation(value: any): value is TextOperation {\r\n    return Operation.isOperation(value) && value.type.endsWith('_text')\r\n  },\r\n\r\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\r\n\r\n  inverse(op: Operation): Operation {\r\n    switch (op.type) {\r\n      case 'insert_node': {\r\n        return { ...op, type: 'remove_node' }\r\n      }\r\n\r\n      case 'insert_text': {\r\n        return { ...op, type: 'remove_text' }\r\n      }\r\n\r\n      case 'merge_node': {\r\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\r\n      }\r\n\r\n      case 'move_node': {\r\n        const { newPath, path } = op\r\n\r\n        // PERF: in this case the move operation is a no-op anyways.\r\n        if (Path.equals(newPath, path)) {\r\n          return op\r\n        }\r\n\r\n        // We need to get the original path here, but sometimes the `newPath`\r\n        // is a younger sibling of (or ends before) the original, and this\r\n        // accounts for it.\r\n        const inversePath = Path.transform(path, op)!\r\n        const inverseNewPath = Path.transform(Path.next(path), op)!\r\n        return { ...op, path: inversePath, newPath: inverseNewPath }\r\n      }\r\n\r\n      case 'remove_node': {\r\n        return { ...op, type: 'insert_node' }\r\n      }\r\n\r\n      case 'remove_text': {\r\n        return { ...op, type: 'insert_text' }\r\n      }\r\n\r\n      case 'set_node': {\r\n        const { properties, newProperties } = op\r\n        return { ...op, properties: newProperties, newProperties: properties }\r\n      }\r\n\r\n      case 'set_selection': {\r\n        const { properties, newProperties } = op\r\n\r\n        if (properties == null) {\r\n          return {\r\n            ...op,\r\n            properties: newProperties as Range,\r\n            newProperties: null,\r\n          }\r\n        } else if (newProperties == null) {\r\n          return {\r\n            ...op,\r\n            properties: null,\r\n            newProperties: properties as Range,\r\n          }\r\n        } else {\r\n          return { ...op, properties: newProperties, newProperties: properties }\r\n        }\r\n      }\r\n\r\n      case 'split_node': {\r\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\r\n      }\r\n    }\r\n  },\r\n}\r\n","import { produce } from 'immer'\r\nimport { Operation } from '..'\r\n\r\n/**\r\n * `Path` arrays are a list of indexes that describe a node's exact position in\r\n * a Slate node tree. Although they are usually relative to the root `Editor`\r\n * object, they can be relative to any `Node` object.\r\n */\r\n\r\nexport type Path = number[]\r\n\r\nexport const Path = {\r\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\r\n\r\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\r\n    const { reverse = false } = options\r\n    let paths = Path.levels(path, options)\r\n\r\n    if (reverse) {\r\n      paths = paths.slice(1)\r\n    } else {\r\n      paths = paths.slice(0, -1)\r\n    }\r\n\r\n    return paths\r\n  },\r\n\r\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\r\n\r\n  common(path: Path, another: Path): Path {\r\n    const common: Path = []\r\n\r\n    for (let i = 0; i < path.length && i < another.length; i++) {\r\n      const av = path[i]\r\n      const bv = another[i]\r\n\r\n      if (av !== bv) {\r\n        break\r\n      }\r\n\r\n      common.push(av)\r\n    }\r\n\r\n    return common\r\n  },\r\n\r\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\r\n\r\n  compare(path: Path, another: Path): -1 | 0 | 1 {\r\n    const min = Math.min(path.length, another.length)\r\n\r\n    for (let i = 0; i < min; i++) {\r\n      if (path[i] < another[i]) return -1\r\n      if (path[i] > another[i]) return 1\r\n    }\r\n\r\n    return 0\r\n  },\r\n\r\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\r\n\r\n  endsAfter(path: Path, another: Path): boolean {\r\n    const i = path.length - 1\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    const av = path[i]\r\n    const bv = another[i]\r\n    return Path.equals(as, bs) && av > bv\r\n  },\r\n\r\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\r\n\r\n  endsAt(path: Path, another: Path): boolean {\r\n    const i = path.length\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    return Path.equals(as, bs)\r\n  },\r\n\r\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\r\n\r\n  endsBefore(path: Path, another: Path): boolean {\r\n    const i = path.length - 1\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    const av = path[i]\r\n    const bv = another[i]\r\n    return Path.equals(as, bs) && av < bv\r\n  },\r\n\r\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\r\n\r\n  equals(path: Path, another: Path): boolean {\r\n    return (\r\n      path.length === another.length && path.every((n, i) => n === another[i])\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a path is after another.\r\n   */\r\n\r\n  isAfter(path: Path, another: Path): boolean {\r\n    return Path.compare(path, another) === 1\r\n  },\r\n\r\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\r\n\r\n  isAncestor(path: Path, another: Path): boolean {\r\n    return path.length < another.length && Path.compare(path, another) === 0\r\n  },\r\n\r\n  /**\r\n   * Check if a path is before another.\r\n   */\r\n\r\n  isBefore(path: Path, another: Path): boolean {\r\n    return Path.compare(path, another) === -1\r\n  },\r\n\r\n  /**\r\n   * Check if a path is a child of another.\r\n   */\r\n\r\n  isChild(path: Path, another: Path): boolean {\r\n    return (\r\n      path.length === another.length + 1 && Path.compare(path, another) === 0\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\r\n\r\n  isCommon(path: Path, another: Path): boolean {\r\n    return path.length <= another.length && Path.compare(path, another) === 0\r\n  },\r\n\r\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\r\n\r\n  isDescendant(path: Path, another: Path): boolean {\r\n    return path.length > another.length && Path.compare(path, another) === 0\r\n  },\r\n\r\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\r\n\r\n  isParent(path: Path, another: Path): boolean {\r\n    return (\r\n      path.length + 1 === another.length && Path.compare(path, another) === 0\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\r\n\r\n  isPath(value: any): value is Path {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || typeof value[0] === 'number')\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\r\n\r\n  isSibling(path: Path, another: Path): boolean {\r\n    if (path.length !== another.length) {\r\n      return false\r\n    }\r\n\r\n    const as = path.slice(0, -1)\r\n    const bs = another.slice(0, -1)\r\n    const al = path[path.length - 1]\r\n    const bl = another[another.length - 1]\r\n    return al !== bl && Path.equals(as, bs)\r\n  },\r\n\r\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\r\n\r\n  levels(\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Path[] {\r\n    const { reverse = false } = options\r\n    const list: Path[] = []\r\n\r\n    for (let i = 0; i <= path.length; i++) {\r\n      list.push(path.slice(0, i))\r\n    }\r\n\r\n    if (reverse) {\r\n      list.reverse()\r\n    }\r\n\r\n    return list\r\n  },\r\n\r\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\r\n\r\n  next(path: Path): Path {\r\n    if (path.length === 0) {\r\n      throw new Error(\r\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\r\n      )\r\n    }\r\n\r\n    const last = path[path.length - 1]\r\n    return path.slice(0, -1).concat(last + 1)\r\n  },\r\n\r\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\r\n\r\n  parent(path: Path): Path {\r\n    if (path.length === 0) {\r\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\r\n    }\r\n\r\n    return path.slice(0, -1)\r\n  },\r\n\r\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\r\n\r\n  previous(path: Path): Path {\r\n    if (path.length === 0) {\r\n      throw new Error(\r\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\r\n      )\r\n    }\r\n\r\n    const last = path[path.length - 1]\r\n\r\n    if (last <= 0) {\r\n      throw new Error(\r\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\r\n      )\r\n    }\r\n\r\n    return path.slice(0, -1).concat(last - 1)\r\n  },\r\n\r\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\r\n\r\n  relative(path: Path, ancestor: Path): Path {\r\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\r\n      throw new Error(\r\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\r\n      )\r\n    }\r\n\r\n    return path.slice(ancestor.length)\r\n  },\r\n\r\n  /**\r\n   * Transform a path by an operation.\r\n   */\r\n\r\n  transform(\r\n    path: Path,\r\n    operation: Operation,\r\n    options: { affinity?: 'forward' | 'backward' | null } = {}\r\n  ): Path | null {\r\n    return produce(path, p => {\r\n      const { affinity = 'forward' } = options\r\n\r\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\r\n      if (path.length === 0) {\r\n        return\r\n      }\r\n\r\n      switch (operation.type) {\r\n        case 'insert_node': {\r\n          const { path: op } = operation\r\n\r\n          if (\r\n            Path.equals(op, p) ||\r\n            Path.endsBefore(op, p) ||\r\n            Path.isAncestor(op, p)\r\n          ) {\r\n            p[op.length - 1] += 1\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_node': {\r\n          const { path: op } = operation\r\n\r\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\r\n            return null\r\n          } else if (Path.endsBefore(op, p)) {\r\n            p[op.length - 1] -= 1\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'merge_node': {\r\n          const { path: op, position } = operation\r\n\r\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\r\n            p[op.length - 1] -= 1\r\n          } else if (Path.isAncestor(op, p)) {\r\n            p[op.length - 1] -= 1\r\n            p[op.length] += position\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'split_node': {\r\n          const { path: op, position } = operation\r\n\r\n          if (Path.equals(op, p)) {\r\n            if (affinity === 'forward') {\r\n              p[p.length - 1] += 1\r\n            } else if (affinity === 'backward') {\r\n              // Nothing, because it still refers to the right path.\r\n            } else {\r\n              return null\r\n            }\r\n          } else if (Path.endsBefore(op, p)) {\r\n            p[op.length - 1] += 1\r\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\r\n            p[op.length - 1] += 1\r\n            p[op.length] -= position\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'move_node': {\r\n          const { path: op, newPath: onp } = operation\r\n\r\n          // If the old and new path are the same, it's a no-op.\r\n          if (Path.equals(op, onp)) {\r\n            return\r\n          }\r\n\r\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\r\n            const copy = onp.slice()\r\n\r\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\r\n              const i = Math.min(onp.length, op.length) - 1\r\n              copy[i] -= 1\r\n            }\r\n\r\n            return copy.concat(p.slice(op.length))\r\n          } else if (\r\n            Path.endsBefore(onp, p) ||\r\n            Path.equals(onp, p) ||\r\n            Path.isAncestor(onp, p)\r\n          ) {\r\n            if (Path.endsBefore(op, p)) {\r\n              p[op.length - 1] -= 1\r\n            }\r\n\r\n            p[onp.length - 1] += 1\r\n          } else if (Path.endsBefore(op, p)) {\r\n            if (Path.equals(onp, p)) {\r\n              p[onp.length - 1] += 1\r\n            }\r\n\r\n            p[op.length - 1] -= 1\r\n          }\r\n\r\n          break\r\n        }\r\n      }\r\n    })\r\n  },\r\n}\r\n","import { Operation, Path } from '..'\r\n\r\n/**\r\n * `PathRef` objects keep a specific path in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date path value.\r\n */\r\n\r\nexport interface PathRef {\r\n  current: Path | null\r\n  affinity: 'forward' | 'backward' | null\r\n  unref(): Path | null\r\n}\r\n\r\nexport const PathRef = {\r\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\r\n\r\n  transform(ref: PathRef, op: Operation): void {\r\n    const { current, affinity } = ref\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const path = Path.transform(current, op, { affinity })\r\n    ref.current = path\r\n\r\n    if (path == null) {\r\n      ref.unref()\r\n    }\r\n  },\r\n}\r\n","import isPlainObject from 'is-plain-object'\r\nimport { produce } from 'immer'\r\nimport { Operation, Path } from '..'\r\n\r\n/**\r\n * `Point` objects refer to a specific location in a text node in a Slate\r\n * document. Its path refers to the location of the node in the tree, and its\r\n * offset refers to the distance into the node's string of text. Points can\r\n * only refer to `Text` nodes.\r\n */\r\n\r\nexport interface Point {\r\n  path: Path\r\n  offset: number\r\n  [key: string]: any\r\n}\r\n\r\nexport const Point = {\r\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\r\n\r\n  compare(point: Point, another: Point): -1 | 0 | 1 {\r\n    const result = Path.compare(point.path, another.path)\r\n\r\n    if (result === 0) {\r\n      if (point.offset < another.offset) return -1\r\n      if (point.offset > another.offset) return 1\r\n      return 0\r\n    }\r\n\r\n    return result\r\n  },\r\n\r\n  /**\r\n   * Check if a point is after another.\r\n   */\r\n\r\n  isAfter(point: Point, another: Point): boolean {\r\n    return Point.compare(point, another) === 1\r\n  },\r\n\r\n  /**\r\n   * Check if a point is before another.\r\n   */\r\n\r\n  isBefore(point: Point, another: Point): boolean {\r\n    return Point.compare(point, another) === -1\r\n  },\r\n\r\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\r\n\r\n  equals(point: Point, another: Point): boolean {\r\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\r\n    return (\r\n      point.offset === another.offset && Path.equals(point.path, another.path)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\r\n\r\n  isPoint(value: any): value is Point {\r\n    return (\r\n      isPlainObject(value) &&\r\n      typeof value.offset === 'number' &&\r\n      Path.isPath(value.path)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Transform a point by an operation.\r\n   */\r\n\r\n  transform(\r\n    point: Point,\r\n    op: Operation,\r\n    options: { affinity?: 'forward' | 'backward' | null } = {}\r\n  ): Point | null {\r\n    return produce(point, p => {\r\n      const { affinity = 'forward' } = options\r\n      const { path, offset } = p\r\n\r\n      switch (op.type) {\r\n        case 'insert_node':\r\n        case 'move_node': {\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'insert_text': {\r\n          if (Path.equals(op.path, path) && op.offset <= offset) {\r\n            p.offset += op.text.length\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'merge_node': {\r\n          if (Path.equals(op.path, path)) {\r\n            p.offset += op.position\r\n          }\r\n\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'remove_text': {\r\n          if (Path.equals(op.path, path) && op.offset <= offset) {\r\n            p.offset -= Math.min(offset - op.offset, op.text.length)\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_node': {\r\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\r\n            return null\r\n          }\r\n\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'split_node': {\r\n          if (Path.equals(op.path, path)) {\r\n            if (op.position === offset && affinity == null) {\r\n              return null\r\n            } else if (\r\n              op.position < offset ||\r\n              (op.position === offset && affinity === 'forward')\r\n            ) {\r\n              p.offset -= op.position\r\n\r\n              p.path = Path.transform(path, op, {\r\n                ...options,\r\n                affinity: 'forward',\r\n              })!\r\n            }\r\n          } else {\r\n            p.path = Path.transform(path, op, options)!\r\n          }\r\n\r\n          break\r\n        }\r\n      }\r\n    })\r\n  },\r\n}\r\n\r\n/**\r\n * `PointEntry` objects are returned when iterating over `Point` objects that\r\n * belong to a range.\r\n */\r\n\r\nexport type PointEntry = [Point, 'anchor' | 'focus']\r\n","import { Operation, Point } from '..'\r\n\r\n/**\r\n * `PointRef` objects keep a specific point in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date point value.\r\n */\r\n\r\nexport interface PointRef {\r\n  current: Point | null\r\n  affinity: 'forward' | 'backward' | null\r\n  unref(): Point | null\r\n}\r\n\r\nexport const PointRef = {\r\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\r\n\r\n  transform(ref: PointRef, op: Operation): void {\r\n    const { current, affinity } = ref\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const point = Point.transform(current, op, { affinity })\r\n    ref.current = point\r\n\r\n    if (point == null) {\r\n      ref.unref()\r\n    }\r\n  },\r\n}\r\n","import { produce } from 'immer'\r\nimport isPlainObject from 'is-plain-object'\r\nimport { Operation, Path, Point, PointEntry } from '..'\r\n\r\n/**\r\n * `Range` objects are a set of points that refer to a specific span of a Slate\r\n * document. They can define a span inside a single node or a can span across\r\n * multiple nodes.\r\n */\r\n\r\nexport interface Range {\r\n  anchor: Point\r\n  focus: Point\r\n  [key: string]: any\r\n}\r\n\r\nexport const Range = {\r\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\r\n\r\n  edges(\r\n    range: Range,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): [Point, Point] {\r\n    const { reverse = false } = options\r\n    const { anchor, focus } = range\r\n    return Range.isBackward(range) === reverse\r\n      ? [anchor, focus]\r\n      : [focus, anchor]\r\n  },\r\n\r\n  /**\r\n   * Get the end point of a range.\r\n   */\r\n\r\n  end(range: Range): Point {\r\n    const [, end] = Range.edges(range)\r\n    return end\r\n  },\r\n\r\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\r\n\r\n  equals(range: Range, another: Range): boolean {\r\n    return (\r\n      Point.equals(range.anchor, another.anchor) &&\r\n      Point.equals(range.focus, another.focus)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\r\n\r\n  includes(range: Range, target: Path | Point | Range): boolean {\r\n    if (Range.isRange(target)) {\r\n      if (\r\n        Range.includes(range, target.anchor) ||\r\n        Range.includes(range, target.focus)\r\n      ) {\r\n        return true\r\n      }\r\n\r\n      const [rs, re] = Range.edges(range)\r\n      const [ts, te] = Range.edges(target)\r\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\r\n    }\r\n\r\n    const [start, end] = Range.edges(range)\r\n    let isAfterStart = false\r\n    let isBeforeEnd = false\r\n\r\n    if (Point.isPoint(target)) {\r\n      isAfterStart = Point.compare(target, start) >= 0\r\n      isBeforeEnd = Point.compare(target, end) <= 0\r\n    } else {\r\n      isAfterStart = Path.compare(target, start.path) >= 0\r\n      isBeforeEnd = Path.compare(target, end.path) <= 0\r\n    }\r\n\r\n    return isAfterStart && isBeforeEnd\r\n  },\r\n\r\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\r\n\r\n  intersection(range: Range, another: Range): Range | null {\r\n    const { anchor, focus, ...rest } = range\r\n    const [s1, e1] = Range.edges(range)\r\n    const [s2, e2] = Range.edges(another)\r\n    const start = Point.isBefore(s1, s2) ? s2 : s1\r\n    const end = Point.isBefore(e1, e2) ? e1 : e2\r\n\r\n    if (Point.isBefore(end, start)) {\r\n      return null\r\n    } else {\r\n      return { anchor: start, focus: end, ...rest }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\r\n\r\n  isBackward(range: Range): boolean {\r\n    const { anchor, focus } = range\r\n    return Point.isAfter(anchor, focus)\r\n  },\r\n\r\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\r\n\r\n  isCollapsed(range: Range): boolean {\r\n    const { anchor, focus } = range\r\n    return Point.equals(anchor, focus)\r\n  },\r\n\r\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\r\n\r\n  isExpanded(range: Range): boolean {\r\n    return !Range.isCollapsed(range)\r\n  },\r\n\r\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\r\n\r\n  isForward(range: Range): boolean {\r\n    return !Range.isBackward(range)\r\n  },\r\n\r\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\r\n\r\n  isRange(value: any): value is Range {\r\n    return (\r\n      isPlainObject(value) &&\r\n      Point.isPoint(value.anchor) &&\r\n      Point.isPoint(value.focus)\r\n    )\r\n  },\r\n\r\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\r\n\r\n  *points(range: Range): Iterable<PointEntry> {\r\n    yield [range.anchor, 'anchor']\r\n    yield [range.focus, 'focus']\r\n  },\r\n\r\n  /**\r\n   * Get the start point of a range.\r\n   */\r\n\r\n  start(range: Range): Point {\r\n    const [start] = Range.edges(range)\r\n    return start\r\n  },\r\n\r\n  /**\r\n   * Transform a range by an operation.\r\n   */\r\n\r\n  transform(\r\n    range: Range,\r\n    op: Operation,\r\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\r\n  ): Range | null {\r\n    const { affinity = 'inward' } = options\r\n    let affinityAnchor: 'forward' | 'backward' | null\r\n    let affinityFocus: 'forward' | 'backward' | null\r\n\r\n    if (affinity === 'inward') {\r\n      if (Range.isForward(range)) {\r\n        affinityAnchor = 'forward'\r\n        affinityFocus = 'backward'\r\n      } else {\r\n        affinityAnchor = 'backward'\r\n        affinityFocus = 'forward'\r\n      }\r\n    } else if (affinity === 'outward') {\r\n      if (Range.isForward(range)) {\r\n        affinityAnchor = 'backward'\r\n        affinityFocus = 'forward'\r\n      } else {\r\n        affinityAnchor = 'forward'\r\n        affinityFocus = 'backward'\r\n      }\r\n    } else {\r\n      affinityAnchor = affinity\r\n      affinityFocus = affinity\r\n    }\r\n\r\n    return produce(range, r => {\r\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\r\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\r\n\r\n      if (!anchor || !focus) {\r\n        return null\r\n      }\r\n\r\n      r.anchor = anchor\r\n      r.focus = focus\r\n    })\r\n  },\r\n}\r\n","import { Operation, Range } from '..'\r\n\r\n/**\r\n * `RangeRef` objects keep a specific range in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date range value.\r\n */\r\n\r\nexport interface RangeRef {\r\n  current: Range | null\r\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\r\n  unref(): Range | null\r\n}\r\n\r\nexport const RangeRef = {\r\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\r\n\r\n  transform(ref: RangeRef, op: Operation): void {\r\n    const { current, affinity } = ref\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const path = Range.transform(current, op, { affinity })\r\n    ref.current = path\r\n\r\n    if (path == null) {\r\n      ref.unref()\r\n    }\r\n  },\r\n}\r\n","import isPlainObject from 'is-plain-object'\r\nimport { Range } from '..'\r\n\r\n/**\r\n * `Text` objects represent the nodes that contain the actual text content of a\r\n * Slate document along with any formatting properties. They are always leaf\r\n * nodes in the document tree as they cannot contain any children.\r\n */\r\n\r\nexport interface Text {\r\n  text: string\r\n  [key: string]: any\r\n}\r\n\r\nexport const Text = {\r\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\r\n\r\n  equals(\r\n    text: Text,\r\n    another: Text,\r\n    options: { loose?: boolean } = {}\r\n  ): boolean {\r\n    const { loose = false } = options\r\n\r\n    for (const key in text) {\r\n      if (loose && key === 'text') {\r\n        continue\r\n      }\r\n\r\n      if (text[key] !== another[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    for (const key in another) {\r\n      if (loose && key === 'text') {\r\n        continue\r\n      }\r\n\r\n      if (text[key] !== another[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  },\r\n\r\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\r\n\r\n  isText(value: any): value is Text {\r\n    return isPlainObject(value) && typeof value.text === 'string'\r\n  },\r\n\r\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\r\n\r\n  isTextList(value: any): value is Text[] {\r\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\r\n  },\r\n\r\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\r\n\r\n  matches(text: Text, props: Partial<Text>): boolean {\r\n    for (const key in props) {\r\n      if (key === 'text') {\r\n        continue\r\n      }\r\n\r\n      if (text[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  },\r\n\r\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\r\n\r\n  decorations(node: Text, decorations: Range[]): Text[] {\r\n    let leaves: Text[] = [{ ...node }]\r\n\r\n    for (const dec of decorations) {\r\n      const { anchor, focus, ...rest } = dec\r\n      const [start, end] = Range.edges(dec)\r\n      const next = []\r\n      let o = 0\r\n\r\n      for (const leaf of leaves) {\r\n        const { length } = leaf.text\r\n        const offset = o\r\n        o += length\r\n\r\n        // If the range encompases the entire leaf, add the range.\r\n        if (start.offset <= offset && end.offset >= offset + length) {\r\n          Object.assign(leaf, rest)\r\n          next.push(leaf)\r\n          continue\r\n        }\r\n\r\n        // If the range starts after the leaf, or ends before it, continue.\r\n        if (\r\n          start.offset > offset + length ||\r\n          end.offset < offset ||\r\n          (end.offset === offset && offset !== 0)\r\n        ) {\r\n          next.push(leaf)\r\n          continue\r\n        }\r\n\r\n        // Otherwise we need to split the leaf, at the start, end, or both,\r\n        // and add the range to the middle intersecting section. Do the end\r\n        // split first since we don't need to update the offset that way.\r\n        let middle = leaf\r\n        let before\r\n        let after\r\n\r\n        if (end.offset < offset + length) {\r\n          const off = end.offset - offset\r\n          after = { ...middle, text: middle.text.slice(off) }\r\n          middle = { ...middle, text: middle.text.slice(0, off) }\r\n        }\r\n\r\n        if (start.offset > offset) {\r\n          const off = start.offset - offset\r\n          before = { ...middle, text: middle.text.slice(0, off) }\r\n          middle = { ...middle, text: middle.text.slice(off) }\r\n        }\r\n\r\n        Object.assign(middle, rest)\r\n\r\n        if (before) {\r\n          next.push(before)\r\n        }\r\n\r\n        next.push(middle)\r\n\r\n        if (after) {\r\n          next.push(after)\r\n        }\r\n      }\r\n\r\n      leaves = next\r\n    }\r\n\r\n    return leaves\r\n  },\r\n}\r\n","import { createDraft, finishDraft, isDraft } from 'immer'\r\nimport {\r\n  Node,\r\n  Editor,\r\n  Range,\r\n  Point,\r\n  Text,\r\n  Element,\r\n  Operation,\r\n  Descendant,\r\n  NodeEntry,\r\n  Path,\r\n  Transforms,\r\n} from '..'\r\n\r\nexport const GeneralTransforms = {\r\n  /**\r\n   * Transform the editor by an operation.\r\n   */\r\n\r\n  transform(editor: Editor, op: Operation) {\r\n    editor.children = createDraft(editor.children)\r\n    let selection = editor.selection && createDraft(editor.selection)\r\n\r\n    switch (op.type) {\r\n      case 'insert_node': {\r\n        const { path, node } = op\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n        parent.children.splice(index, 0, node)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'insert_text': {\r\n        const { path, offset, text } = op\r\n        const node = Node.leaf(editor, path)\r\n        const before = node.text.slice(0, offset)\r\n        const after = node.text.slice(offset)\r\n        node.text = before + text + after\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'merge_node': {\r\n        const { path } = op\r\n        const node = Node.get(editor, path)\r\n        const prevPath = Path.previous(path)\r\n        const prev = Node.get(editor, prevPath)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n\r\n        if (Text.isText(node) && Text.isText(prev)) {\r\n          prev.text += node.text\r\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\r\n          prev.children.push(...node.children)\r\n        } else {\r\n          throw new Error(\r\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\r\n          )\r\n        }\r\n\r\n        parent.children.splice(index, 1)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'move_node': {\r\n        const { path, newPath } = op\r\n\r\n        if (Path.isAncestor(path, newPath)) {\r\n          throw new Error(\r\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\r\n          )\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n\r\n        // This is tricky, but since the `path` and `newPath` both refer to\r\n        // the same snapshot in time, there's a mismatch. After either\r\n        // removing the original position, the second step's path can be out\r\n        // of date. So instead of using the `op.newPath` directly, we\r\n        // transform `op.path` to ascertain what the `newPath` would be after\r\n        // the operation was applied.\r\n        parent.children.splice(index, 1)\r\n        const truePath = Path.transform(path, op)!\r\n        const newParent = Node.get(editor, Path.parent(truePath))\r\n        const newIndex = truePath[truePath.length - 1]\r\n\r\n        newParent.children.splice(newIndex, 0, node)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'remove_node': {\r\n        const { path } = op\r\n        const index = path[path.length - 1]\r\n        const parent = Node.parent(editor, path)\r\n        parent.children.splice(index, 1)\r\n\r\n        // Transform all of the points in the value, but if the point was in the\r\n        // node that was removed we need to update the range or remove it.\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            const result = Point.transform(point, op)\r\n\r\n            if (selection != null && result != null) {\r\n              selection[key] = result\r\n            } else {\r\n              let prev: NodeEntry<Text> | undefined\r\n              let next: NodeEntry<Text> | undefined\r\n\r\n              for (const [n, p] of Node.texts(editor)) {\r\n                if (Path.compare(p, path) === -1) {\r\n                  prev = [n, p]\r\n                } else {\r\n                  next = [n, p]\r\n                  break\r\n                }\r\n              }\r\n\r\n              if (prev) {\r\n                point.path = prev[1]\r\n                point.offset = prev[0].text.length\r\n              } else if (next) {\r\n                point.path = next[1]\r\n                point.offset = 0\r\n              } else {\r\n                selection = null\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'remove_text': {\r\n        const { path, offset, text } = op\r\n        const node = Node.leaf(editor, path)\r\n        const before = node.text.slice(0, offset)\r\n        const after = node.text.slice(offset + text.length)\r\n        node.text = before + after\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'set_node': {\r\n        const { path, newProperties } = op\r\n\r\n        if (path.length === 0) {\r\n          throw new Error(`Cannot set properties on the root node!`)\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n\r\n        for (const key in newProperties) {\r\n          if (key === 'children' || key === 'text') {\r\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\r\n          }\r\n\r\n          const value = newProperties[key]\r\n\r\n          if (value == null) {\r\n            delete node[key]\r\n          } else {\r\n            node[key] = value\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'set_selection': {\r\n        const { newProperties } = op\r\n\r\n        if (newProperties == null) {\r\n          selection = newProperties\r\n        } else if (selection == null) {\r\n          if (!Range.isRange(newProperties)) {\r\n            throw new Error(\r\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\r\n                newProperties\r\n              )} when there is no current selection.`\r\n            )\r\n          }\r\n\r\n          selection = newProperties\r\n        } else {\r\n          Object.assign(selection, newProperties)\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case 'split_node': {\r\n        const { path, position, properties } = op\r\n\r\n        if (path.length === 0) {\r\n          throw new Error(\r\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\r\n          )\r\n        }\r\n\r\n        const node = Node.get(editor, path)\r\n        const parent = Node.parent(editor, path)\r\n        const index = path[path.length - 1]\r\n        let newNode: Descendant\r\n\r\n        if (Text.isText(node)) {\r\n          const before = node.text.slice(0, position)\r\n          const after = node.text.slice(position)\r\n          node.text = before\r\n          newNode = {\r\n            ...node,\r\n            ...(properties as Partial<Text>),\r\n            text: after,\r\n          }\r\n        } else {\r\n          const before = node.children.slice(0, position)\r\n          const after = node.children.slice(position)\r\n          node.children = before\r\n\r\n          newNode = {\r\n            ...node,\r\n            ...(properties as Partial<Element>),\r\n            children: after,\r\n          }\r\n        }\r\n\r\n        parent.children.splice(index + 1, 0, newNode)\r\n\r\n        if (selection) {\r\n          for (const [point, key] of Range.points(selection)) {\r\n            selection[key] = Point.transform(point, op)!\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n    }\r\n\r\n    editor.children = finishDraft(editor.children) as Node[]\r\n\r\n    if (selection) {\r\n      editor.selection = isDraft(selection)\r\n        ? (finishDraft(selection) as Range)\r\n        : selection\r\n    } else {\r\n      editor.selection = null\r\n    }\r\n  },\r\n}\r\n","import {\r\n  Editor,\r\n  Element,\r\n  Location,\r\n  Node,\r\n  Path,\r\n  Point,\r\n  Range,\r\n  Text,\r\n  Transforms,\r\n} from '..'\r\n\r\nexport const NodeTransforms = {\r\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\r\n\r\n  insertNodes(\r\n    editor: Editor,\r\n    nodes: Node | Node[],\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'highest' | 'lowest'\r\n      hanging?: boolean\r\n      select?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { hanging = false, voids = false, mode = 'lowest' } = options\r\n      let { at, match, select } = options\r\n\r\n      if (Node.isNode(nodes)) {\r\n        nodes = [nodes]\r\n      }\r\n\r\n      if (nodes.length === 0) {\r\n        return\r\n      }\r\n\r\n      const [node] = nodes\r\n\r\n      // By default, use the selection as the target location. But if there is\r\n      // no selection, insert at the end of the document since that is such a\r\n      // common use case when inserting from a non-selected state.\r\n      if (!at) {\r\n        if (editor.selection) {\r\n          at = editor.selection\r\n        } else if (editor.children.length > 0) {\r\n          at = Editor.end(editor, [])\r\n        } else {\r\n          at = [0]\r\n        }\r\n\r\n        select = true\r\n      }\r\n\r\n      if (select == null) {\r\n        select = false\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (!hanging) {\r\n          at = Editor.unhangRange(editor, at)\r\n        }\r\n\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n          const pointRef = Editor.pointRef(editor, end)\r\n          Transforms.delete(editor, { at })\r\n          at = pointRef.unref()!\r\n        }\r\n      }\r\n\r\n      if (Point.isPoint(at)) {\r\n        if (match == null) {\r\n          if (Text.isText(node)) {\r\n            match = n => Text.isText(n)\r\n          } else if (editor.isInline(node)) {\r\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\r\n          } else {\r\n            match = n => Editor.isBlock(editor, n)\r\n          }\r\n        }\r\n\r\n        const [entry] = Editor.nodes(editor, {\r\n          at: at.path,\r\n          match,\r\n          mode,\r\n          voids,\r\n        })\r\n\r\n        if (entry) {\r\n          const [, matchPath] = entry\r\n          const pathRef = Editor.pathRef(editor, matchPath)\r\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\r\n          Transforms.splitNodes(editor, { at, match, mode, voids })\r\n          const path = pathRef.unref()!\r\n          at = isAtEnd ? Path.next(path) : path\r\n        } else {\r\n          return\r\n        }\r\n      }\r\n\r\n      const parentPath = Path.parent(at)\r\n      let index = at[at.length - 1]\r\n\r\n      if (!voids && Editor.void(editor, { at: parentPath })) {\r\n        return\r\n      }\r\n\r\n      for (const node of nodes) {\r\n        const path = parentPath.concat(index)\r\n        index++\r\n        editor.apply({ type: 'insert_node', path, node })\r\n      }\r\n\r\n      if (select) {\r\n        const point = Editor.end(editor, at)\r\n\r\n        if (point) {\r\n          Transforms.select(editor, point)\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\r\n\r\n  liftNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\r\n      let { match } = options\r\n\r\n      if (match == null) {\r\n        match = Path.isPath(at)\r\n          ? matchPath(editor, at)\r\n          : n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\r\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n\r\n        if (path.length < 2) {\r\n          throw new Error(\r\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\r\n          )\r\n        }\r\n\r\n        const [parent, parentPath] = Editor.node(editor, Path.parent(path))\r\n        const index = path[path.length - 1]\r\n        const { length } = parent.children\r\n\r\n        if (length === 1) {\r\n          const toPath = Path.next(parentPath)\r\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\r\n          Transforms.removeNodes(editor, { at: parentPath, voids })\r\n        } else if (index === 0) {\r\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\r\n        } else if (index === length - 1) {\r\n          const toPath = Path.next(parentPath)\r\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\r\n        } else {\r\n          const splitPath = Path.next(path)\r\n          const toPath = Path.next(parentPath)\r\n          Transforms.splitNodes(editor, { at: splitPath, voids })\r\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\r\n\r\n  mergeNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'highest' | 'lowest'\r\n      hanging?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      let { match, at = editor.selection } = options\r\n      const { hanging = false, voids = false, mode = 'lowest' } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const [parent] = Editor.parent(editor, at)\r\n          match = n => parent.children.includes(n)\r\n        } else {\r\n          match = n => Editor.isBlock(editor, n)\r\n        }\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = Editor.unhangRange(editor, at)\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n          const pointRef = Editor.pointRef(editor, end)\r\n          Transforms.delete(editor, { at })\r\n          at = pointRef.unref()!\r\n\r\n          if (options.at == null) {\r\n            Transforms.select(editor, at)\r\n          }\r\n        }\r\n      }\r\n\r\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\r\n      const prev = Editor.previous(editor, { at, match, voids, mode })\r\n\r\n      if (!current || !prev) {\r\n        return\r\n      }\r\n\r\n      const [node, path] = current\r\n      const [prevNode, prevPath] = prev\r\n\r\n      if (path.length === 0 || prevPath.length === 0) {\r\n        return\r\n      }\r\n\r\n      const newPath = Path.next(prevPath)\r\n      const commonPath = Path.common(path, prevPath)\r\n      const isPreviousSibling = Path.isSibling(path, prevPath)\r\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\r\n        .slice(commonPath.length)\r\n        .slice(0, -1)\r\n\r\n      // Determine if the merge will leave an ancestor of the path empty as a\r\n      // result, in which case we'll want to remove it after merging.\r\n      const emptyAncestor = Editor.above(editor, {\r\n        at: path,\r\n        mode: 'highest',\r\n        match: n =>\r\n          levels.includes(n) && Element.isElement(n) && n.children.length === 1,\r\n      })\r\n\r\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\r\n      let properties\r\n      let position\r\n\r\n      // Ensure that the nodes are equivalent, and figure out what the position\r\n      // and extra properties of the merge will be.\r\n      if (Text.isText(node) && Text.isText(prevNode)) {\r\n        const { text, ...rest } = node\r\n        position = prevNode.text.length\r\n        properties = rest as Partial<Text>\r\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\r\n        const { children, ...rest } = node\r\n        position = prevNode.children.length\r\n        properties = rest as Partial<Element>\r\n      } else {\r\n        throw new Error(\r\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\r\n            node\r\n          )} ${JSON.stringify(prevNode)}`\r\n        )\r\n      }\r\n\r\n      // If the node isn't already the next sibling of the previous node, move\r\n      // it so that it is before merging.\r\n      if (!isPreviousSibling) {\r\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\r\n      }\r\n\r\n      // If there was going to be an empty ancestor of the node that was merged,\r\n      // we remove it from the tree.\r\n      if (emptyRef) {\r\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\r\n      }\r\n\r\n      // If the target node that we're merging with is empty, remove it instead\r\n      // of merging the two. This is a common rich text editor behavior to\r\n      // prevent losing formatting when deleting entire nodes when you have a\r\n      // hanging selection.\r\n      if (\r\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\r\n        (Text.isText(prevNode) && prevNode.text === '')\r\n      ) {\r\n        Transforms.removeNodes(editor, { at: prevPath, voids })\r\n      } else {\r\n        editor.apply({\r\n          type: 'merge_node',\r\n          path: newPath,\r\n          position,\r\n          target: null,\r\n          properties,\r\n        })\r\n      }\r\n\r\n      if (emptyRef) {\r\n        emptyRef.unref()\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\r\n\r\n  moveNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      to: Path\r\n      voids?: boolean\r\n    }\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const {\r\n        to,\r\n        at = editor.selection,\r\n        mode = 'lowest',\r\n        voids = false,\r\n      } = options\r\n      let { match } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        match = Path.isPath(at)\r\n          ? matchPath(editor, at)\r\n          : n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      const toRef = Editor.pathRef(editor, to)\r\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\r\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        const newPath = toRef.current!\r\n\r\n        if (path.length !== 0) {\r\n          editor.apply({ type: 'move_node', path, newPath })\r\n        }\r\n      }\r\n\r\n      toRef.unref()\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\r\n\r\n  removeNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'highest' | 'lowest'\r\n      hanging?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { hanging = false, voids = false, mode = 'lowest' } = options\r\n      let { at = editor.selection, match } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        match = Path.isPath(at)\r\n          ? matchPath(editor, at)\r\n          : n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = Editor.unhangRange(editor, at)\r\n      }\r\n\r\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\r\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n\r\n        if (path) {\r\n          const [node] = Editor.node(editor, path)\r\n          editor.apply({ type: 'remove_node', path, node })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\r\n\r\n  setNodes(\r\n    editor: Editor,\r\n    props: Partial<Node>,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      hanging?: boolean\r\n      split?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      let { match, at = editor.selection } = options\r\n      const {\r\n        hanging = false,\r\n        mode = 'lowest',\r\n        split = false,\r\n        voids = false,\r\n      } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        match = Path.isPath(at)\r\n          ? matchPath(editor, at)\r\n          : n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = Editor.unhangRange(editor, at)\r\n      }\r\n\r\n      if (split && Range.isRange(at)) {\r\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\r\n        const [start, end] = Range.edges(at)\r\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\r\n        Transforms.splitNodes(editor, {\r\n          at: end,\r\n          match,\r\n          mode: splitMode,\r\n          voids,\r\n        })\r\n        Transforms.splitNodes(editor, {\r\n          at: start,\r\n          match,\r\n          mode: splitMode,\r\n          voids,\r\n        })\r\n        at = rangeRef.unref()!\r\n\r\n        if (options.at == null) {\r\n          Transforms.select(editor, at)\r\n        }\r\n      }\r\n\r\n      for (const [node, path] of Editor.nodes(editor, {\r\n        at,\r\n        match,\r\n        mode,\r\n        voids,\r\n      })) {\r\n        const properties: Partial<Node> = {}\r\n        const newProperties: Partial<Node> = {}\r\n\r\n        // You can't set properties on the editor node.\r\n        if (path.length === 0) {\r\n          continue\r\n        }\r\n\r\n        for (const k in props) {\r\n          if (k === 'children' || k === 'text') {\r\n            continue\r\n          }\r\n\r\n          if (props[k] !== node[k]) {\r\n            properties[k] = node[k]\r\n            newProperties[k] = props[k]\r\n          }\r\n        }\r\n\r\n        if (Object.keys(newProperties).length !== 0) {\r\n          editor.apply({\r\n            type: 'set_node',\r\n            path,\r\n            properties,\r\n            newProperties,\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\r\n\r\n  splitNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'highest' | 'lowest'\r\n      always?: boolean\r\n      height?: number\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { mode = 'lowest', voids = false } = options\r\n      let { match, at = editor.selection, height = 0, always = false } = options\r\n\r\n      if (match == null) {\r\n        match = n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        at = deleteRange(editor, at)\r\n      }\r\n\r\n      // If the target is a path, the default height-skipping and position\r\n      // counters need to account for us potentially splitting at a non-leaf.\r\n      if (Path.isPath(at)) {\r\n        const path = at\r\n        const point = Editor.point(editor, path)\r\n        const [parent] = Editor.parent(editor, path)\r\n        match = n => n === parent\r\n        height = point.path.length - path.length + 1\r\n        at = point\r\n        always = true\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const beforeRef = Editor.pointRef(editor, at, {\r\n        affinity: 'backward',\r\n      })\r\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\r\n\r\n      if (!highest) {\r\n        return\r\n      }\r\n\r\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\r\n      const nudge = 0\r\n\r\n      if (!voids && voidMatch) {\r\n        const [voidNode, voidPath] = voidMatch\r\n\r\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\r\n          let after = Editor.after(editor, voidPath)\r\n\r\n          if (!after) {\r\n            const text = { text: '' }\r\n            const afterPath = Path.next(voidPath)\r\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\r\n            after = Editor.point(editor, afterPath)!\r\n          }\r\n\r\n          at = after\r\n          always = true\r\n        }\r\n\r\n        const siblingHeight = at.path.length - voidPath.length\r\n        height = siblingHeight + 1\r\n        always = true\r\n      }\r\n\r\n      const afterRef = Editor.pointRef(editor, at)\r\n      const depth = at.path.length - height\r\n      const [, highestPath] = highest\r\n      const lowestPath = at.path.slice(0, depth)\r\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\r\n      let target: number | null = null\r\n\r\n      for (const [node, path] of Editor.levels(editor, {\r\n        at: lowestPath,\r\n        reverse: true,\r\n        voids,\r\n      })) {\r\n        let split = false\r\n\r\n        if (\r\n          path.length < highestPath.length ||\r\n          path.length === 0 ||\r\n          (!voids && Editor.isVoid(editor, node))\r\n        ) {\r\n          break\r\n        }\r\n\r\n        const point = beforeRef.current!\r\n        const isEnd = Editor.isEnd(editor, point, path)\r\n\r\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\r\n          split = true\r\n          const { text, children, ...properties } = node\r\n          editor.apply({\r\n            type: 'split_node',\r\n            path,\r\n            position,\r\n            target,\r\n            properties,\r\n          })\r\n        }\r\n\r\n        target = position\r\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\r\n      }\r\n\r\n      if (options.at == null) {\r\n        const point = afterRef.current || Editor.end(editor, [])\r\n        Transforms.select(editor, point)\r\n      }\r\n\r\n      beforeRef.unref()\r\n      afterRef.unref()\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\r\n\r\n  unsetNodes(\r\n    editor: Editor,\r\n    props: string | string[],\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      split?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    if (!Array.isArray(props)) {\r\n      props = [props]\r\n    }\r\n\r\n    const obj = {}\r\n\r\n    for (const key of props) {\r\n      obj[key] = null\r\n    }\r\n\r\n    Transforms.setNodes(editor, obj, options)\r\n  },\r\n\r\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\r\n\r\n  unwrapNodes(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      split?: boolean\r\n      voids?: boolean\r\n    }\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { mode = 'lowest', split = false, voids = false } = options\r\n      let { at = editor.selection, match } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        match = Path.isPath(at)\r\n          ? matchPath(editor, at)\r\n          : n => Editor.isBlock(editor, n)\r\n      }\r\n\r\n      if (Path.isPath(at)) {\r\n        at = Editor.range(editor, at)\r\n      }\r\n\r\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\r\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\r\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        const [node] = Editor.node(editor, path)\r\n        let range = Editor.range(editor, path)\r\n\r\n        if (split && rangeRef) {\r\n          range = Range.intersection(rangeRef.current!, range)!\r\n        }\r\n\r\n        Transforms.liftNodes(editor, {\r\n          at: range,\r\n          match: n => node.children.includes(n),\r\n          voids,\r\n        })\r\n      }\r\n\r\n      if (rangeRef) {\r\n        rangeRef.unref()\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\r\n\r\n  wrapNodes(\r\n    editor: Editor,\r\n    element: Element,\r\n    options: {\r\n      at?: Location\r\n      match?: (node: Node) => boolean\r\n      mode?: 'all' | 'highest' | 'lowest'\r\n      split?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { mode = 'lowest', split = false, voids = false } = options\r\n      let { match, at = editor.selection } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          match = matchPath(editor, at)\r\n        } else if (editor.isInline(element)) {\r\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\r\n        } else {\r\n          match = n => Editor.isBlock(editor, n)\r\n        }\r\n      }\r\n\r\n      if (split && Range.isRange(at)) {\r\n        const [start, end] = Range.edges(at)\r\n        const rangeRef = Editor.rangeRef(editor, at, {\r\n          affinity: 'inward',\r\n        })\r\n        Transforms.splitNodes(editor, { at: end, match, voids })\r\n        Transforms.splitNodes(editor, { at: start, match, voids })\r\n        at = rangeRef.unref()!\r\n\r\n        if (options.at == null) {\r\n          Transforms.select(editor, at)\r\n        }\r\n      }\r\n\r\n      const roots = Array.from(\r\n        Editor.nodes(editor, {\r\n          at,\r\n          match: editor.isInline(element)\r\n            ? n => Editor.isBlock(editor, n)\r\n            : n => Editor.isEditor(n),\r\n          mode: 'highest',\r\n          voids,\r\n        })\r\n      )\r\n\r\n      for (const [, rootPath] of roots) {\r\n        const a = Range.isRange(at)\r\n          ? Range.intersection(at, Editor.range(editor, rootPath))\r\n          : at\r\n\r\n        if (!a) {\r\n          continue\r\n        }\r\n\r\n        const matches = Array.from(\r\n          Editor.nodes(editor, { at: a, match, mode, voids })\r\n        )\r\n\r\n        if (matches.length > 0) {\r\n          const [first] = matches\r\n          const last = matches[matches.length - 1]\r\n          const [, firstPath] = first\r\n          const [, lastPath] = last\r\n          const commonPath = Path.equals(firstPath, lastPath)\r\n            ? Path.parent(firstPath)\r\n            : Path.common(firstPath, lastPath)\r\n\r\n          const range = Editor.range(editor, firstPath, lastPath)\r\n          const [commonNode] = Editor.node(editor, commonPath)\r\n          const depth = commonPath.length + 1\r\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\r\n          const wrapper = { ...element, children: [] }\r\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\r\n\r\n          Transforms.moveNodes(editor, {\r\n            at: range,\r\n            match: n => commonNode.children.includes(n),\r\n            to: wrapperPath.concat(0),\r\n            voids,\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n}\r\n\r\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\r\n\r\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\r\n  if (Range.isCollapsed(range)) {\r\n    return range.anchor\r\n  } else {\r\n    const [, end] = Range.edges(range)\r\n    const pointRef = Editor.pointRef(editor, end)\r\n    Transforms.delete(editor, { at: range })\r\n    return pointRef.unref()\r\n  }\r\n}\r\n\r\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\r\n  const [node] = Editor.node(editor, path)\r\n  return n => n === node\r\n}\r\n","import { Editor, Location, Point, Range, Transforms } from '..'\r\n\r\nexport const SelectionTransforms = {\r\n  /**\r\n   * Collapse the selection.\r\n   */\r\n\r\n  collapse(\r\n    editor: Editor,\r\n    options: {\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    } = {}\r\n  ) {\r\n    const { edge = 'anchor' } = options\r\n    const { selection } = editor\r\n\r\n    if (!selection) {\r\n      return\r\n    } else if (edge === 'anchor') {\r\n      Transforms.select(editor, selection.anchor)\r\n    } else if (edge === 'focus') {\r\n      Transforms.select(editor, selection.focus)\r\n    } else if (edge === 'start') {\r\n      const [start] = Range.edges(selection)\r\n      Transforms.select(editor, start)\r\n    } else if (edge === 'end') {\r\n      const [, end] = Range.edges(selection)\r\n      Transforms.select(editor, end)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Unset the selection.\r\n   */\r\n\r\n  deselect(editor: Editor) {\r\n    const { selection } = editor\r\n\r\n    if (selection) {\r\n      editor.apply({\r\n        type: 'set_selection',\r\n        properties: selection,\r\n        newProperties: null,\r\n      })\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\r\n\r\n  move(\r\n    editor: Editor,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line'\r\n      reverse?: boolean\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    } = {}\r\n  ) {\r\n    const { selection } = editor\r\n    const { distance = 1, unit = 'character', reverse = false } = options\r\n    let { edge = null } = options\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    if (edge === 'start') {\r\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\r\n    }\r\n\r\n    if (edge === 'end') {\r\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\r\n    }\r\n\r\n    const { anchor, focus } = selection\r\n    const opts = { distance, unit }\r\n    const props: Partial<Range> = {}\r\n\r\n    if (edge == null || edge === 'anchor') {\r\n      const point = reverse\r\n        ? Editor.before(editor, anchor, opts)\r\n        : Editor.after(editor, anchor, opts)\r\n\r\n      if (point) {\r\n        props.anchor = point\r\n      }\r\n    }\r\n\r\n    if (edge == null || edge === 'focus') {\r\n      const point = reverse\r\n        ? Editor.before(editor, focus, opts)\r\n        : Editor.after(editor, focus, opts)\r\n\r\n      if (point) {\r\n        props.focus = point\r\n      }\r\n    }\r\n\r\n    Transforms.setSelection(editor, props)\r\n  },\r\n\r\n  /**\r\n   * Set the selection to a new value.\r\n   */\r\n\r\n  select(editor: Editor, target: Location) {\r\n    const { selection } = editor\r\n    target = Editor.range(editor, target)\r\n\r\n    if (selection) {\r\n      Transforms.setSelection(editor, target)\r\n      return\r\n    }\r\n\r\n    if (!Range.isRange(target)) {\r\n      throw new Error(\r\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\r\n          target\r\n        )}`\r\n      )\r\n    }\r\n\r\n    editor.apply({\r\n      type: 'set_selection',\r\n      properties: selection,\r\n      newProperties: target,\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\r\n\r\n  setPoint(\r\n    editor: Editor,\r\n    props: Partial<Point>,\r\n    options: {\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    }\r\n  ) {\r\n    const { selection } = editor\r\n    let { edge = 'both' } = options\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    if (edge === 'start') {\r\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\r\n    }\r\n\r\n    if (edge === 'end') {\r\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\r\n    }\r\n\r\n    const { anchor, focus } = selection\r\n    const point = edge === 'anchor' ? anchor : focus\r\n\r\n    Transforms.setSelection(editor, {\r\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Set new properties on the selection.\r\n   */\r\n\r\n  setSelection(editor: Editor, props: Partial<Range>) {\r\n    const { selection } = editor\r\n    const oldProps: Partial<Range> | null = {}\r\n    const newProps: Partial<Range> = {}\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    for (const k in props) {\r\n      if (\r\n        (k === 'anchor' &&\r\n          props.anchor != null &&\r\n          !Point.equals(props.anchor, selection.anchor)) ||\r\n        (k === 'focus' &&\r\n          props.focus != null &&\r\n          !Point.equals(props.focus, selection.focus)) ||\r\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\r\n      ) {\r\n        oldProps[k] = selection[k]\r\n        newProps[k] = props[k]\r\n      }\r\n    }\r\n\r\n    if (Object.keys(oldProps).length > 0) {\r\n      editor.apply({\r\n        type: 'set_selection',\r\n        properties: oldProps,\r\n        newProperties: newProps,\r\n      })\r\n    }\r\n  },\r\n}\r\n","import {\r\n  Editor,\r\n  Element,\r\n  Location,\r\n  Node,\r\n  NodeEntry,\r\n  Path,\r\n  Text,\r\n  Point,\r\n  Range,\r\n  Transforms,\r\n} from '..'\r\n\r\nexport const TextTransforms = {\r\n  /**\r\n   * Delete content in the editor.\r\n   */\r\n\r\n  delete(\r\n    editor: Editor,\r\n    options: {\r\n      at?: Location\r\n      distance?: number\r\n      unit?: 'character' | 'word' | 'line' | 'block'\r\n      reverse?: boolean\r\n      hanging?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const {\r\n        reverse = false,\r\n        unit = 'character',\r\n        distance = 1,\r\n        voids = false,\r\n      } = options\r\n      let { at = editor.selection, hanging = false } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\r\n        at = at.anchor\r\n      }\r\n\r\n      if (Point.isPoint(at)) {\r\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\r\n\r\n        if (!voids && furthestVoid) {\r\n          const [, voidPath] = furthestVoid\r\n          at = voidPath\r\n        } else {\r\n          const opts = { unit, distance }\r\n          const target = reverse\r\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\r\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\r\n          at = { anchor: at, focus: target }\r\n          hanging = true\r\n        }\r\n      }\r\n\r\n      if (Path.isPath(at)) {\r\n        Transforms.removeNodes(editor, { at, voids })\r\n        return\r\n      }\r\n\r\n      if (Range.isCollapsed(at)) {\r\n        return\r\n      }\r\n\r\n      if (!hanging) {\r\n        at = Editor.unhangRange(editor, at, { voids })\r\n      }\r\n\r\n      let [start, end] = Range.edges(at)\r\n      const startBlock = Editor.above(editor, {\r\n        match: n => Editor.isBlock(editor, n),\r\n        at: start,\r\n        voids,\r\n      })\r\n      const endBlock = Editor.above(editor, {\r\n        match: n => Editor.isBlock(editor, n),\r\n        at: end,\r\n        voids,\r\n      })\r\n      const isAcrossBlocks =\r\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\r\n      const isSingleText = Path.equals(start.path, end.path)\r\n      const startVoid = voids\r\n        ? null\r\n        : Editor.void(editor, { at: start, mode: 'highest' })\r\n      const endVoid = voids\r\n        ? null\r\n        : Editor.void(editor, { at: end, mode: 'highest' })\r\n\r\n      // If the start or end points are inside an inline void, nudge them out.\r\n      if (startVoid) {\r\n        const before = Editor.before(editor, start)\r\n\r\n        if (\r\n          before &&\r\n          startBlock &&\r\n          Path.isAncestor(startBlock[1], before.path)\r\n        ) {\r\n          start = before\r\n        }\r\n      }\r\n\r\n      if (endVoid) {\r\n        const after = Editor.after(editor, end)\r\n\r\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\r\n          end = after\r\n        }\r\n      }\r\n\r\n      // Get the highest nodes that are completely inside the range, as well as\r\n      // the start and end nodes.\r\n      const matches: NodeEntry[] = []\r\n      let lastPath: Path | undefined\r\n\r\n      for (const entry of Editor.nodes(editor, { at, voids })) {\r\n        const [node, path] = entry\r\n\r\n        if (lastPath && Path.compare(path, lastPath) === 0) {\r\n          continue\r\n        }\r\n\r\n        if (\r\n          (!voids && Editor.isVoid(editor, node)) ||\r\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\r\n        ) {\r\n          matches.push(entry)\r\n          lastPath = path\r\n        }\r\n      }\r\n\r\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\r\n      const startRef = Editor.pointRef(editor, start)\r\n      const endRef = Editor.pointRef(editor, end)\r\n\r\n      if (!isSingleText && !startVoid) {\r\n        const point = startRef.current!\r\n        const [node] = Editor.leaf(editor, point)\r\n        const { path } = point\r\n        const { offset } = start\r\n        const text = node.text.slice(offset)\r\n        editor.apply({ type: 'remove_text', path, offset, text })\r\n      }\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        Transforms.removeNodes(editor, { at: path, voids })\r\n      }\r\n\r\n      if (!endVoid) {\r\n        const point = endRef.current!\r\n        const [node] = Editor.leaf(editor, point)\r\n        const { path } = point\r\n        const offset = isSingleText ? start.offset : 0\r\n        const text = node.text.slice(offset, end.offset)\r\n        editor.apply({ type: 'remove_text', path, offset, text })\r\n      }\r\n\r\n      if (\r\n        !isSingleText &&\r\n        isAcrossBlocks &&\r\n        endRef.current &&\r\n        startRef.current\r\n      ) {\r\n        Transforms.mergeNodes(editor, {\r\n          at: endRef.current,\r\n          hanging: true,\r\n          voids,\r\n        })\r\n      }\r\n\r\n      const point = endRef.unref() || startRef.unref()\r\n\r\n      if (options.at == null && point) {\r\n        Transforms.select(editor, point)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\r\n\r\n  insertFragment(\r\n    editor: Editor,\r\n    fragment: Node[],\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { hanging = false, voids = false } = options\r\n      let { at = editor.selection } = options\r\n\r\n      if (!fragment.length) {\r\n        return\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      } else if (Range.isRange(at)) {\r\n        if (!hanging) {\r\n          at = Editor.unhangRange(editor, at)\r\n        }\r\n\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n\r\n          if (!voids && Editor.void(editor, { at: end })) {\r\n            return\r\n          }\r\n\r\n          const pointRef = Editor.pointRef(editor, end)\r\n          Transforms.delete(editor, { at })\r\n          at = pointRef.unref()!\r\n        }\r\n      } else if (Path.isPath(at)) {\r\n        at = Editor.start(editor, at)\r\n      }\r\n\r\n      if (!voids && Editor.void(editor, { at })) {\r\n        return\r\n      }\r\n\r\n      // If the insert point is at the edge of an inline node, move it outside\r\n      // instead since it will need to be split otherwise.\r\n      const inlineElementMatch = Editor.above(editor, {\r\n        at,\r\n        match: n => Editor.isInline(editor, n),\r\n        mode: 'highest',\r\n        voids,\r\n      })\r\n\r\n      if (inlineElementMatch) {\r\n        const [, inlinePath] = inlineElementMatch\r\n\r\n        if (Editor.isEnd(editor, at, inlinePath)) {\r\n          const after = Editor.after(editor, inlinePath)!\r\n          at = after\r\n        } else if (Editor.isStart(editor, at, inlinePath)) {\r\n          const before = Editor.before(editor, inlinePath)!\r\n          at = before\r\n        }\r\n      }\r\n\r\n      const blockMatch = Editor.above(editor, {\r\n        match: n => Editor.isBlock(editor, n),\r\n        at,\r\n        voids,\r\n      })!\r\n      const [, blockPath] = blockMatch\r\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\r\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\r\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\r\n      const mergeEnd = !isBlockEnd\r\n      const [, firstPath] = Node.first({ children: fragment }, [])\r\n      const [, lastPath] = Node.last({ children: fragment }, [])\r\n\r\n      const matches: NodeEntry[] = []\r\n      const matcher = ([n, p]: NodeEntry) => {\r\n        if (\r\n          mergeStart &&\r\n          Path.isAncestor(p, firstPath) &&\r\n          Element.isElement(n) &&\r\n          !editor.isVoid(n) &&\r\n          !editor.isInline(n)\r\n        ) {\r\n          return false\r\n        }\r\n\r\n        if (\r\n          mergeEnd &&\r\n          Path.isAncestor(p, lastPath) &&\r\n          Element.isElement(n) &&\r\n          !editor.isVoid(n) &&\r\n          !editor.isInline(n)\r\n        ) {\r\n          return false\r\n        }\r\n\r\n        return true\r\n      }\r\n\r\n      for (const entry of Node.nodes(\r\n        { children: fragment },\r\n        { pass: matcher }\r\n      )) {\r\n        if (entry[1].length > 0 && matcher(entry)) {\r\n          matches.push(entry)\r\n        }\r\n      }\r\n\r\n      const starts = []\r\n      const middles = []\r\n      const ends = []\r\n      let starting = true\r\n      let hasBlocks = false\r\n\r\n      for (const [node] of matches) {\r\n        if (Element.isElement(node) && !editor.isInline(node)) {\r\n          starting = false\r\n          hasBlocks = true\r\n          middles.push(node)\r\n        } else if (starting) {\r\n          starts.push(node)\r\n        } else {\r\n          ends.push(node)\r\n        }\r\n      }\r\n\r\n      const [inlineMatch] = Editor.nodes(editor, {\r\n        at,\r\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\r\n        mode: 'highest',\r\n        voids,\r\n      })!\r\n\r\n      const [, inlinePath] = inlineMatch\r\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\r\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\r\n\r\n      const middleRef = Editor.pathRef(\r\n        editor,\r\n        isBlockEnd ? Path.next(blockPath) : blockPath\r\n      )\r\n\r\n      const endRef = Editor.pathRef(\r\n        editor,\r\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\r\n      )\r\n\r\n      Transforms.splitNodes(editor, {\r\n        at,\r\n        match: n =>\r\n          hasBlocks\r\n            ? Editor.isBlock(editor, n)\r\n            : Text.isText(n) || Editor.isInline(editor, n),\r\n        mode: hasBlocks ? 'lowest' : 'highest',\r\n        voids,\r\n      })\r\n\r\n      const startRef = Editor.pathRef(\r\n        editor,\r\n        !isInlineStart || (isInlineStart && isInlineEnd)\r\n          ? Path.next(inlinePath)\r\n          : inlinePath\r\n      )\r\n\r\n      Transforms.insertNodes(editor, starts, {\r\n        at: startRef.current!,\r\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\r\n        mode: 'highest',\r\n        voids,\r\n      })\r\n\r\n      Transforms.insertNodes(editor, middles, {\r\n        at: middleRef.current!,\r\n        match: n => Editor.isBlock(editor, n),\r\n        mode: 'lowest',\r\n        voids,\r\n      })\r\n\r\n      Transforms.insertNodes(editor, ends, {\r\n        at: endRef.current!,\r\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\r\n        mode: 'highest',\r\n        voids,\r\n      })\r\n\r\n      if (!options.at) {\r\n        let path\r\n\r\n        if (ends.length > 0) {\r\n          path = Path.previous(endRef.current!)\r\n        } else if (middles.length > 0) {\r\n          path = Path.previous(middleRef.current!)\r\n        } else {\r\n          path = Path.previous(startRef.current!)\r\n        }\r\n\r\n        const end = Editor.end(editor, path)\r\n        Transforms.select(editor, end)\r\n      }\r\n\r\n      startRef.unref()\r\n      middleRef.unref()\r\n      endRef.unref()\r\n    })\r\n  },\r\n\r\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\r\n\r\n  insertText(\r\n    editor: Editor,\r\n    text: string,\r\n    options: {\r\n      at?: Location\r\n      voids?: boolean\r\n    } = {}\r\n  ) {\r\n    Editor.withoutNormalizing(editor, () => {\r\n      const { voids = false } = options\r\n      let { at = editor.selection } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (Path.isPath(at)) {\r\n        at = Editor.range(editor, at)\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const end = Range.end(at)\r\n\r\n          if (!voids && Editor.void(editor, { at: end })) {\r\n            return\r\n          }\r\n\r\n          const pointRef = Editor.pointRef(editor, end)\r\n          Transforms.delete(editor, { at, voids })\r\n          at = pointRef.unref()!\r\n          Transforms.setSelection(editor, { anchor: at, focus: at })\r\n        }\r\n      }\r\n\r\n      if (!voids && Editor.void(editor, { at })) {\r\n        return\r\n      }\r\n\r\n      const { path, offset } = at\r\n      editor.apply({ type: 'insert_text', path, offset, text })\r\n    })\r\n  },\r\n}\r\n","import { GeneralTransforms } from './general'\r\nimport { NodeTransforms } from './node'\r\nimport { SelectionTransforms } from './selection'\r\nimport { TextTransforms } from './text'\r\n\r\nexport const Transforms = {\r\n  ...GeneralTransforms,\r\n  ...NodeTransforms,\r\n  ...SelectionTransforms,\r\n  ...TextTransforms,\r\n}\r\n","import {\r\n  Descendant,\r\n  Editor,\r\n  Element,\r\n  Node,\r\n  NodeEntry,\r\n  Operation,\r\n  Path,\r\n  PathRef,\r\n  PointRef,\r\n  Range,\r\n  RangeRef,\r\n  Text,\r\n  Transforms,\r\n} from './'\r\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\r\n\r\n/**\r\n * Create a new Slate `Editor` object.\r\n */\r\n\r\nexport const createEditor = (): Editor => {\r\n  const editor: Editor = {\r\n    children: [],\r\n    operations: [],\r\n    selection: null,\r\n    marks: null,\r\n    isInline: () => false,\r\n    isVoid: () => false,\r\n    onChange: () => {},\r\n\r\n    apply: (op: Operation) => {\r\n      for (const ref of Editor.pathRefs(editor)) {\r\n        PathRef.transform(ref, op)\r\n      }\r\n\r\n      for (const ref of Editor.pointRefs(editor)) {\r\n        PointRef.transform(ref, op)\r\n      }\r\n\r\n      for (const ref of Editor.rangeRefs(editor)) {\r\n        RangeRef.transform(ref, op)\r\n      }\r\n\r\n      const set = new Set()\r\n      const dirtyPaths: Path[] = []\r\n\r\n      const add = (path: Path | null) => {\r\n        if (path) {\r\n          const key = path.join(',')\r\n\r\n          if (!set.has(key)) {\r\n            set.add(key)\r\n            dirtyPaths.push(path)\r\n          }\r\n        }\r\n      }\r\n\r\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\r\n      const newDirtyPaths = getDirtyPaths(op)\r\n\r\n      for (const path of oldDirtyPaths) {\r\n        const newPath = Path.transform(path, op)\r\n        add(newPath)\r\n      }\r\n\r\n      for (const path of newDirtyPaths) {\r\n        add(path)\r\n      }\r\n\r\n      DIRTY_PATHS.set(editor, dirtyPaths)\r\n      Editor.transform(editor, op)\r\n      editor.operations.push(op)\r\n      Editor.normalize(editor)\r\n\r\n      // Clear any formats applied to the cursor if the selection changes.\r\n      if (op.type === 'set_selection') {\r\n        editor.marks = null\r\n      }\r\n\r\n      if (!FLUSHING.get(editor)) {\r\n        FLUSHING.set(editor, true)\r\n\r\n        Promise.resolve().then(() => {\r\n          FLUSHING.set(editor, false)\r\n          editor.onChange()\r\n          editor.operations = []\r\n        })\r\n      }\r\n    },\r\n\r\n    addMark: (key: string, value: any) => {\r\n      const { selection } = editor\r\n\r\n      if (selection) {\r\n        if (Range.isExpanded(selection)) {\r\n          Transforms.setNodes(\r\n            editor,\r\n            { [key]: value },\r\n            { match: Text.isText, split: true }\r\n          )\r\n        } else {\r\n          const marks = {\r\n            ...(Editor.marks(editor) || {}),\r\n            [key]: value,\r\n          }\r\n\r\n          editor.marks = marks\r\n          editor.onChange()\r\n        }\r\n      }\r\n    },\r\n\r\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\r\n      const { selection } = editor\r\n\r\n      if (selection && Range.isCollapsed(selection)) {\r\n        Transforms.delete(editor, { unit, reverse: true })\r\n      }\r\n    },\r\n\r\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\r\n      const { selection } = editor\r\n\r\n      if (selection && Range.isCollapsed(selection)) {\r\n        Transforms.delete(editor, { unit })\r\n      }\r\n    },\r\n\r\n    deleteFragment: () => {\r\n      const { selection } = editor\r\n\r\n      if (selection && Range.isExpanded(selection)) {\r\n        Transforms.delete(editor)\r\n      }\r\n    },\r\n    getFragment: () => {\r\n      const { selection } = editor\r\n\r\n      if (selection && Range.isExpanded(selection)) {\r\n        return Node.fragment(editor, selection)\r\n      }\r\n      return []\r\n    },\r\n\r\n    insertBreak: () => {\r\n      Transforms.splitNodes(editor, { always: true })\r\n    },\r\n\r\n    insertFragment: (fragment: Node[]) => {\r\n      Transforms.insertFragment(editor, fragment)\r\n    },\r\n\r\n    insertNode: (node: Node) => {\r\n      Transforms.insertNodes(editor, node)\r\n    },\r\n\r\n    insertText: (text: string) => {\r\n      const { selection, marks } = editor\r\n\r\n      if (selection) {\r\n        // If the cursor is at the end of an inline, move it outside of\r\n        // the inline before inserting\r\n        if (Range.isCollapsed(selection)) {\r\n          const inline = Editor.above(editor, {\r\n            match: n => Editor.isInline(editor, n),\r\n            mode: 'highest',\r\n          })\r\n\r\n          if (inline) {\r\n            const [, inlinePath] = inline\r\n\r\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\r\n              const point = Editor.after(editor, inlinePath)!\r\n              Transforms.setSelection(editor, {\r\n                anchor: point,\r\n                focus: point,\r\n              })\r\n            }\r\n          }\r\n        }\r\n\r\n        if (marks) {\r\n          const node = { text, ...marks }\r\n          Transforms.insertNodes(editor, node)\r\n        } else {\r\n          Transforms.insertText(editor, text)\r\n        }\r\n\r\n        editor.marks = null\r\n      }\r\n    },\r\n\r\n    normalizeNode: (entry: NodeEntry) => {\r\n      const [node, path] = entry\r\n\r\n      // There are no core normalizations for text nodes.\r\n      if (Text.isText(node)) {\r\n        return\r\n      }\r\n\r\n      // Ensure that block and inline nodes have at least one text child.\r\n      if (Element.isElement(node) && node.children.length === 0) {\r\n        const child = { text: '' }\r\n        Transforms.insertNodes(editor, child, {\r\n          at: path.concat(0),\r\n          voids: true,\r\n        })\r\n        return\r\n      }\r\n\r\n      // Determine whether the node should have block or inline children.\r\n      const shouldHaveInlines = Editor.isEditor(node)\r\n        ? false\r\n        : Element.isElement(node) &&\r\n          (editor.isInline(node) ||\r\n            node.children.length === 0 ||\r\n            Text.isText(node.children[0]) ||\r\n            editor.isInline(node.children[0]))\r\n\r\n      // Since we'll be applying operations while iterating, keep track of an\r\n      // index that accounts for any added/removed nodes.\r\n      let n = 0\r\n\r\n      for (let i = 0; i < node.children.length; i++, n++) {\r\n        const child = node.children[i] as Descendant\r\n        const prev = node.children[i - 1] as Descendant\r\n        const isLast = i === node.children.length - 1\r\n        const isInlineOrText =\r\n          Text.isText(child) ||\r\n          (Element.isElement(child) && editor.isInline(child))\r\n\r\n        // Only allow block nodes in the top-level children and parent blocks\r\n        // that only contain block nodes. Similarly, only allow inline nodes in\r\n        // other inline nodes, or parent blocks that only contain inlines and\r\n        // text.\r\n        if (isInlineOrText !== shouldHaveInlines) {\r\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\r\n          n--\r\n        } else if (Element.isElement(child)) {\r\n          // Ensure that inline nodes are surrounded by text nodes.\r\n          if (editor.isInline(child)) {\r\n            if (prev == null || !Text.isText(prev)) {\r\n              const newChild = { text: '' }\r\n              Transforms.insertNodes(editor, newChild, {\r\n                at: path.concat(n),\r\n                voids: true,\r\n              })\r\n              n++\r\n            } else if (isLast) {\r\n              const newChild = { text: '' }\r\n              Transforms.insertNodes(editor, newChild, {\r\n                at: path.concat(n + 1),\r\n                voids: true,\r\n              })\r\n              n++\r\n            }\r\n          }\r\n        } else {\r\n          // Merge adjacent text nodes that are empty or match.\r\n          if (prev != null && Text.isText(prev)) {\r\n            if (Text.equals(child, prev, { loose: true })) {\r\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\r\n              n--\r\n            } else if (prev.text === '') {\r\n              Transforms.removeNodes(editor, {\r\n                at: path.concat(n - 1),\r\n                voids: true,\r\n              })\r\n              n--\r\n            } else if (isLast && child.text === '') {\r\n              Transforms.removeNodes(editor, {\r\n                at: path.concat(n),\r\n                voids: true,\r\n              })\r\n              n--\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    removeMark: (key: string) => {\r\n      const { selection } = editor\r\n\r\n      if (selection) {\r\n        if (Range.isExpanded(selection)) {\r\n          Transforms.unsetNodes(editor, key, {\r\n            match: Text.isText,\r\n            split: true,\r\n          })\r\n        } else {\r\n          const marks = { ...(Editor.marks(editor) || {}) }\r\n          delete marks[key]\r\n          editor.marks = marks\r\n          editor.onChange()\r\n        }\r\n      }\r\n    },\r\n  }\r\n\r\n  return editor\r\n}\r\n\r\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\r\n\r\nconst getDirtyPaths = (op: Operation) => {\r\n  switch (op.type) {\r\n    case 'insert_text':\r\n    case 'remove_text':\r\n    case 'set_node': {\r\n      const { path } = op\r\n      return Path.levels(path)\r\n    }\r\n\r\n    case 'insert_node': {\r\n      const { node, path } = op\r\n      const levels = Path.levels(path)\r\n      const descendants = Text.isText(node)\r\n        ? []\r\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\r\n\r\n      return [...levels, ...descendants]\r\n    }\r\n\r\n    case 'merge_node': {\r\n      const { path } = op\r\n      const ancestors = Path.ancestors(path)\r\n      const previousPath = Path.previous(path)\r\n      return [...ancestors, previousPath]\r\n    }\r\n\r\n    case 'move_node': {\r\n      const { path, newPath } = op\r\n\r\n      if (Path.equals(path, newPath)) {\r\n        return []\r\n      }\r\n\r\n      const oldAncestors: Path[] = []\r\n      const newAncestors: Path[] = []\r\n\r\n      for (const ancestor of Path.ancestors(path)) {\r\n        const p = Path.transform(ancestor, op)\r\n        oldAncestors.push(p!)\r\n      }\r\n\r\n      for (const ancestor of Path.ancestors(newPath)) {\r\n        const p = Path.transform(ancestor, op)\r\n        newAncestors.push(p!)\r\n      }\r\n\r\n      return [...oldAncestors, ...newAncestors]\r\n    }\r\n\r\n    case 'remove_node': {\r\n      const { path } = op\r\n      const ancestors = Path.ancestors(path)\r\n      return [...ancestors]\r\n    }\r\n\r\n    case 'split_node': {\r\n      const { path } = op\r\n      const levels = Path.levels(path)\r\n      const nextPath = Path.next(path)\r\n      return [...levels, nextPath]\r\n    }\r\n\r\n    default: {\r\n      return []\r\n    }\r\n  }\r\n}\r\n"],"names":["objectWithoutPropertiesLoose","DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","text","offset","prev","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","length","i","started","char","charAt","l","slice","rest","isWordCharacter","remaining","test","next","code","Editor","above","editor","options","voids","mode","at","selection","match","path","reverse","n","p","levels","Text","isText","Path","equals","addMark","key","value","after","anchor","point","edge","focus","end","range","distance","d","target","positions","before","start","deleteBackward","unit","deleteForward","deleteFragment","edges","first","node","fragment","Node","hasBlocks","element","children","some","isBlock","hasInlines","isInline","hasTexts","every","insertBreak","insertFragment","insertNode","insertText","Element","isElement","isEditor","isPlainObject","apply","isVoid","normalizeNode","onChange","removeMark","marks","Range","isRange","isNodeList","Operation","isOperationList","operations","isEnd","Point","isEdge","isStart","isEmpty","isNormalizing","get","undefined","last","leaf","push","isExpanded","nodes","previous","block","prevNode","prevPath","blockPath","isAncestor","from","to","span","isPath","Error","parent","includes","universal","Span","isSpan","iterable","pass","matches","hit","isLower","compare","emit","normalize","force","getDirtyPaths","allPaths","Array","set","withoutNormalizing","max","m","pop","entry","parentPath","depth","firstPath","lastPath","common","isPoint","pathRef","affinity","ref","current","unref","pathRefs","delete","refs","add","Set","pointRef","pointRefs","string","available","isNewBlock","advance","e","s","reverseText","isFirst","rangeRef","rangeRefs","t","transform","op","createDraft","type","index","splice","points","newPath","truePath","newParent","newIndex","result","texts","newProperties","JSON","stringify","Object","assign","position","properties","newNode","finishDraft","isDraft","unhangRange","isCollapsed","endBlock","skip","isBefore","void","fn","isElementList","isArray","props","Location","isLocation","ancestor","root","ancestors","child","c","childPath","concat","another","descendant","descendants","elements","newRoot","produce","r","has","isNode","visited","isAfter","nextIndex","map","join","isNodeOperation","isOperation","endsWith","isSelectionOperation","isTextOperation","inverse","inversePath","inverseNewPath","paths","av","bv","min","Math","endsAfter","as","bs","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","isSibling","al","bl","list","relative","operation","onp","copy","PathRef","PointRef","isBackward","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isForward","affinityAnchor","affinityFocus","RangeRef","loose","isTextList","decorations","leaves","dec","o","middle","off","GeneralTransforms","NodeTransforms","insertNodes","hanging","select","Transforms","matchPath","isAtEnd","splitNodes","liftNodes","toPath","moveNodes","removeNodes","splitPath","mergeNodes","commonPath","isPreviousSibling","emptyAncestor","emptyRef","toRef","targets","depths","setNodes","split","splitMode","k","keys","height","always","deleteRange","beforeRef","highest","voidMatch","nudge","voidNode","voidPath","afterPath","siblingHeight","afterRef","highestPath","lowestPath","unsetNodes","obj","unwrapNodes","wrapNodes","roots","rootPath","a","commonNode","wrapperPath","wrapper","SelectionTransforms","collapse","deselect","move","opts","setSelection","setPoint","oldProps","newProps","TextTransforms","furthestVoid","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","inlinePath","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef","createEditor","dirtyPaths","oldDirtyPaths","newDirtyPaths","Promise","resolve","then","getFragment","inline","shouldHaveInlines","isLast","isInlineOrText","newChild","previousPath","oldAncestors","newAncestors","nextPath"],"mappings":"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"}